{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://xaviermin.github.io","root":"/"},"pages":[],"posts":[{"title":"利用Arm DesignStart计划开放的处理器核搭建SoC-工具篇","slug":"利用Arm DesignStart计划开放的处理器核搭建SoC-工具篇","date":"2021-07-14T01:20:59.349Z","updated":"2021-07-14T01:20:33.083Z","comments":true,"path":"2021/07/14/利用Arm DesignStart计划开放的处理器核搭建SoC-工具篇/","link":"","permalink":"http://xaviermin.github.io/2021/07/14/%E5%88%A9%E7%94%A8Arm%20DesignStart%E8%AE%A1%E5%88%92%E5%BC%80%E6%94%BE%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%B8%E6%90%AD%E5%BB%BASoC-%E5%B7%A5%E5%85%B7%E7%AF%87/","excerpt":"SoCSoC(System on Chip)：称为系统级芯片，也有称片上系统，意指它是一个产品，是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。同时它又是一种技术，用以实现从确定系统功能开始，到软/硬件划分，并完成设计的整个过程。SoC是一个完整的系统，既包含处理器核、总线、外设等硬件，也包含处理器需要执行的指令。","text":"SoCSoC(System on Chip)：称为系统级芯片，也有称片上系统，意指它是一个产品，是一个有专用目标的集成电路，其中包含完整系统并有嵌入软件的全部内容。同时它又是一种技术，用以实现从确定系统功能开始，到软/硬件划分，并完成设计的整个过程。SoC是一个完整的系统，既包含处理器核、总线、外设等硬件，也包含处理器需要执行的指令。 本文介绍在使用Arm DesignStart计划开放的处理器核搭建SoC并通过FPGA实现的过程中所用工具软件，理清“软件编程”和“硬件编程”的概念，熟悉SoC设计的流程。 1. 软件工具 仿真：Modelsim 综合：Vivado（Xilinx FPGA）、Quartus（Intel FPGA） WSL(Windows Subsystem for Linux)：make、minucom（串口调试助手） 软件编译调试：Keil 2. 软硬件关系 通过Arm DesignStart获取的是一个Verilog语言描述的软核，再添加一些IP实现一个完整的描述SoC的工程。这些IP可以是用IP工具生成的，也可以是通过硬件描述语言（Verilog/VHDL）描述的。 Vivado负责将硬件描述语言（Verilog/VHDL）所描述的SoC编译、综合、实现，将FPGA内部本身无序的各种逻辑资源（如查找表、触发器、RAM等）配置成为有序的电路，实现SoC功能。而Keil负责将编写的软件编程语言（C/Assembler）编译成为机器码十六进制文件。将机器码作为RAM的初始化内容，即可进行仿真，在Modelsim软件中观察SoC工作时各个信号的波形。若将机器码通过工具下载到由FPGA实现的SoC中，那么就可以让SoC执行编写的程序，通过FPGA开发板观察执行结果。 从流程中也可以理解“软件编程”和“硬件编程”的区别，“软件编程”编的其实是一条条的指令，描述的是硬件的“动作”，而“硬件编程”编的是一个个的门电路和它们的连接关系，描述的是是硬件的结构。 3. ModelsimModelsim主要用于硬件描述语言（Verilog，VHDL等）的仿真，并且支持VHDL和Verilog混合仿真。仿真分为前仿（RTL级仿真）和后仿（综合后门级仿真），这里使用Modelsim仿真属于前仿，也就是功能仿真，主要目的是通过看输出波形图，验证硬件逻辑是否正确。 Modelsim既可以独立使用，也可以和Intel Quartus Prime，Xilinx Vivado软件协同使用。 4. VivadoVivado是一个用于FPGA实现的综合工具，由FPGA厂商Xilinx提供，如果使用Intel（Altera）公司的FPGA，需要使用Quartus Prime软件。 从前述内容中知道，Vivado负责将硬件描述语言（Verilog/VHDL）所描述的SoC编译、综合、实现，将FPGA内部本身无序的各种逻辑资源（如查找表、触发器、RAM等）配置成为有序的电路，实现SoC功能。 5. KeilKeil MDK是可用于一系列基于Arm Cortex-M的微控制器设备的一个完整的软件开发环境。与Xilinx Vivado软件类似，主界面也是由工具栏、工程目录、代码编辑、调试信息组成。Keil软件的主要作用是将C语言/汇编语言写的程序编译成机器码，在进入调试模式时，通过调试器下载机器码到RAM中，CPU启动后，开始一条条地从存储器中取指执行。","categories":[],"tags":[]},{"title":"Ⅰ_Leetcode7_整数反转","slug":"Ⅰ_Leetcode7_整数反转","date":"2021-06-02T17:46:28.125Z","updated":"2021-06-02T17:45:44.484Z","comments":true,"path":"2021/06/03/Ⅰ_Leetcode7_整数反转/","link":"","permalink":"http://xaviermin.github.io/2021/06/03/%E2%85%A0_Leetcode7_%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"题目给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。","text":"题目给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 12输入：x = 123输出：321 示例 2： 12输入：x = -123输出：-321 示例 3： 12输入：x = 120输出：21 示例 4： 12&gt;输入：x = 0&gt;输出：0 1. C实现123456789101112//方法一int reverse(int x){ long long r = 0; while(x) { r = r*10 + x%10; x /= 10; } if(r&gt;pow(2,31) || r&lt;-pow(2,31)-1) return 0; return r;} 此题要点在于如何处理溢出，找个不会溢出的“容器”即可，可使用long long，确保32/64位都不会溢出，但违背了题目的初衷——假设环境不允许存储 64 位整数。 12345678910111213//官方解法int reverse(int x){ int r=0; while(x != 0) { if(r&lt;INT_MIN/10 || r&gt;INT_MAX/10) return 0; int digit = x % 10; x /= 10; r = r * 10 + digit; } return r;} 官方解法用INT_MIN/10和INT_MAX/10进行判断，实际上溢出检测只需要在最后一步进行，改进如下。 123456789101112//官方解法改进int reverse(int x){ int r=0; while(x / 10) { r = r * 10 + x % 10; x /= 10; } if((r&gt;INT_MAX/10) || ((r==INT_MAX/10) &amp;&amp; (x&gt;7)))return 0; else if ((r&lt;INT_MIN/10) || ((r==INT_MAX/10) &amp;&amp; (x&lt;-8)))return 0; else return r * 10 + x;} 2. C++实现12345678910111213141516//官方解法class Solution {public: int reverse(int x) { int r=0; while(x != 0) { if(r&lt;INT_MIN/10 || r&gt;INT_MAX/10) return 0; int digit = x % 10; x /= 10; r = r * 10 + digit; } return r; }}; 3. Python实现12345678910111213141516class Solution: def reverse(self, x: int) -&gt; int: INT_MIN, INT_MAX = -2**31, 2**31-1 r = 0 while x != 0: # INT_MIN也是一个负数，不能写成 r &lt; INT_MIN // 10 if r &lt; INT_MIN // 10 + 1 or r &gt; INT_MAX // 10: return 0 digit = x % 10 # Python3的取模运算在 x 为负数时也会返回[0,9)以内的结果，因此这里特殊判断 if x &lt; 0 and digit &gt; 0: digit -= 10 # 同理，Python3的整数除法在 x 为负数时会向下（更小的负数）取整，因此不能写成 x //= 10 x = (x - digit) // 10 r = r * 10 + digit return r Python算术运算符 //：取整除，返回商的整数部分（向下取整）。 4. Java实现123456789101112131415class Solution { public int reverse(int x) { int r=0; while(x != 0) { if(r&lt;Integer.MIN_VALUE/10 || r&gt;Integer.MAX_VALUE/10) return 0; int digit = x % 10; x /= 10; r = r * 10 + digit; } return r; }} Java中Integer的最小值和最大值：最小值为Integer.MIN_VALUE，即-2147483648，最大值为Integer.MAX_VALUE，即2147483647。","categories":[],"tags":[]},{"title":"Ⅰ_Leetcode1_两数之和","slug":"Ⅰ_Leetcode1_两数之和","date":"2021-05-30T17:16:07.876Z","updated":"2021-05-30T17:23:25.238Z","comments":true,"path":"2021/05/31/Ⅰ_Leetcode1_两数之和/","link":"","permalink":"http://xaviermin.github.io/2021/05/31/%E2%85%A0_Leetcode1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。","text":"题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 示例 1： 123&gt;输入：nums = [2,7,11,15], target = 9&gt;输出：[0,1]&gt;解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12&gt;输入：nums = [3,2,4], target = 6&gt;输出：[1,2] 示例 3： 12&gt;输入：nums = [3,3], target = 6&gt;输出：[0,1] 1. C实现1234567891011121314151617181920/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize){ for(int i= 0; i&lt;numsSize-1; i++) //从第一个元素开始暴力循环 { for(int j=i+1; j&lt;numsSize; j++) //分别与后面的元素相加进行比较 { if(nums[i] + nums[j] == target) //若两元素相加为整数目标值target { int *a = (int*)malloc(sizeof(int) * 2); //申请动态数组 a[0] = i; //将得到的元素下标传入数组 a[1] = j; *returnSize = 2; //返回的数组大小为2 return a; //返回数组 } } } return 0;} 传入参数： *nums：题目中给定的整数数组。 numsSize：该整数数组的大小。 target：题目中给定的整数目标值。 *returnSize：所要返回数组的大小。 注：malloc是C语言中的动态分配内存，int *a = (int*)malloc(sizeof(int) * 2);，malloc函数返回的是void *型，所以要强制类型转换成int，在前面加上int *，才能给整型赋值，后面(sizeof(int) * 2)的意思是分配两个int大小的空间。 该方法简单，但是时间复杂度为O(n^2^)，空间复杂度为O(1)，运行速度慢且内存空间消耗大。 2. C++实现2.1 暴力循环123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; nums_index; for(int i=0; i&lt;nums.size()-1; i++) { for(int j=i+1; j&lt;nums.size(); j++) { if(nums[i] + nums[j] == target) { nums_index.push_back(i); nums_index.push_back(j); } } } return nums_index; }}; 原理同上面C语言实现方法一样。 2.2 hash法（哈希表）12345678910111213141516171819202122232425262728293031323334353637383940//两遍哈希表class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { map&lt;int,int&gt; nummap2; //建立hash表存放数组元素 vector&lt;int&gt; nums_index(2, -1); //初始化一个大小为2，值为-1的容器，存放输出结果 for(int i=0; i&lt;nums.size(); i++) nummap2.insert(map&lt;int,int&gt;::value_type(nums[i], i)); for(int i=0; i&lt;nums.size(); i++) { //判断是否找到目标且目标元素不能是本身 if(nummap2.count(target - nums[i])&gt;0 &amp;&amp; (nummap2[target - nums[i]])!=i) { nums_index[0] = i; nums_index[1] = nummap2[target - nums[i]]; break; } } return nums_index; }};//一遍哈希表class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { map&lt;int,int&gt; nummap1; vector&lt;int&gt; nums_index(2, -1); for(int i=0; i&lt;nums.size(); i++) { if(nummap1.count(target - nums[i])&gt;0) { nums_index[0] = nummap1[target - nums[i]]; nums_index[1] = i; break; } nummap1[nums[i]] = i; //反过来放入map中，用来获取结果下标 } return nums_index; }}; 两遍哈希表：第一遍循环，先把数组nums存到nummap2里面去。第二遍循环，遍历数组，寻找匹配的值。 一遍哈希表：在进行迭代并将元素插入到表中的同时，回过头检查表中是否已经存在target - nums[i]，如果它存在，那就找到了对应解，并break将其返回。 2.3 排序+双指针法12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; nums_index; vector&lt;int&gt; temp; temp = nums; int length = temp.size(); sort(temp.begin(), temp.end()); //排序 int i=0, j=length-1; while(i &lt; j) { if(temp[i] + temp[j] &gt; target)j--; else if(temp[i] + temp[j] &lt; target)i++; else break; } for(int k=0; k&lt;length; ++k) { if(nums[k] == temp[i]) nums_index.push_back(k); else if(nums[k] == temp[j]) nums_index.push_back(k); } return nums_index; }}; 先将数组排好序，再遍历一遍得到结果，另开了一个数组保存下标信息，时间复杂度为O(nlogn)，空间复杂度为O(n)。 3. Python实现3.1 暴力循环1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i, j] return [] 3.2 hash法（哈希表）1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashset = {} for i in range(len(nums)): if hashset.get(target - nums[i]) is not None: return [hashset.get(target - nums[i]), i] hashset[nums[i]] = i 3.3 排序+双指针法12345678910111213141516171819class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: temp = nums.copy() temp.sort() i = 0 j = len(nums) - 1 while i&lt;j: if (temp[i] + temp[j]) &gt; target: j = j - 1 elif (temp[i] + temp[j]) &lt; target: i = i + 1 else: break p = nums.index(temp[i]) nums.pop(p) k = nums.index(temp[j]) if k &gt;= p: k = k + 1 return [p, k] 4. Java实现4.1 暴力循环12345678910111213141516class Solution { public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; for(int i = 0;i&lt;nums.length;i++) { for(int j = i+1;j&lt;nums.length ;j++){ if(nums[i]+nums[j] == target){ res[0] = i; res[1] = j; return res; } } } return res; }} 4.2 hash法（哈希表）123456789101112131415161718192021222324252627282930313233343536373839//两遍哈希表class Solution { public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; HashMap&lt;Integer, Integer&gt; nummap = new HashMap&lt;&gt;(); for(int i = 0;i&lt;nums.length;i++){ nummap.put(nums[i], i); } for(int i = 0;i&lt;=nums.length;i++) { int temp = target - nums[i]; if(nummap.containsKey(temp) &amp;&amp; nummap.get(temp) != i ) { res[0] = i; res[1] = nummap.get(temp); return res; } } return res; }}//一遍哈希表class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer&gt; nummap2 = new HashMap&lt;&gt;(); int lengthnum = nums.length; int temp = 0; for(int i = 0;i&lt;lengthnum ; i++) { temp = target - nums[i]; if(nummap2.containsKey(temp)) { return new int[] {nummap2.get(temp),i} ; //注意这里的先后顺序，一定是nummap2.get(temp)在前，i在后 } else { nummap2.put(nums[i], i); } } return new int[] {0,0}; }} 4.3 排序+双指针法123456789101112131415161718192021222324252627282930313233343536class Solution { public static int[] twoSum(int[] nums, int target) { int[] result = new int[]{-1, -1}; if (nums.length == 2) return new int[]{0, 1}; int[] team = Arrays.copyOf(nums, nums.length); Arrays.sort(team); int l = 0; int r = nums.length - 1; while (true) { if (team[l] + team[r] &gt; target) { r--; continue; } if (team[l] + team[r] &lt; target) { l++; continue; } if (team[l] + team[r] == target) break; } for (int i = 0; i &lt; nums.length; i++) { if (nums[i] == team[l] &amp;&amp; result[0] == -1) { result[0] = i; continue; } if (nums[i] == team[r] &amp;&amp; result[1] == -1) result[1] = i; } return result; }}","categories":[],"tags":[]},{"title":"ESP8266+DHT11+freeboard温湿度上传dweet","slug":"ESP8266+DHT11+freeboard温湿度上传dweet","date":"2021-03-02T16:43:00.088Z","updated":"2021-03-02T16:42:44.193Z","comments":true,"path":"2021/03/03/ESP8266+DHT11+freeboard温湿度上传dweet/","link":"","permalink":"http://xaviermin.github.io/2021/03/03/ESP8266+DHT11+freeboard%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%B8%8A%E4%BC%A0dweet/","excerpt":"MQTTMQTT协议是广泛应用的物联网协议，使用测试MQTT协议需要MQTT的代理。有两种方法：一是租用现成的MQTT服务器，如阿里云、华为云等云平台提供的MQTT服务，使用公用的MQTT服务器的好处是省事，但如果仅仅用于测试学习还需要注册帐号，有的平台还需要付费。另一方法是自己使用开源的MQTT组件来搭建。","text":"MQTTMQTT协议是广泛应用的物联网协议，使用测试MQTT协议需要MQTT的代理。有两种方法：一是租用现成的MQTT服务器，如阿里云、华为云等云平台提供的MQTT服务，使用公用的MQTT服务器的好处是省事，但如果仅仅用于测试学习还需要注册帐号，有的平台还需要付费。另一方法是自己使用开源的MQTT组件来搭建。 1. 准备 硬件：ESP8266（WiFi模块）、DHT11 软件：Arduino、网站dweet.io 2. 硬件接线 ESP8266-WiFi模块 DHT11温湿度传感器模块 VCC (3V) VCC GND GND D4 DATA (数据线) 3. Python上传数据到dweet云平台dweet.io是个蛮不错的网站，对于小型的IOT项目，可以通过它把数据同步至云端，方便远程实时监控。结合 freeboard的小插件，美观又实用。 例：用Python生成随机数上传dweet来显示效果，电脑搭好Python环境，安装dweepy模块（负责与 dweet.io 站点的通信） pip install dweepy 代码如下： 12345678910111213141516171819import dweepyimport timeimport randomif __name__ == '__main__': while True: thing_name = \"Xavier-min-hello-world\" # 生成两个随机数替代真实数据 temperature = random.uniform(20, 30) humidity = random.uniform(40, 50) dweet = {\"temperature\": \"{:5.2f}\".format(temperature), \"humidity\": \"{:5.2f}\".format(humidity)} dweepy.dweet_for(thing_name, dweet) print(\"temperature \" + dweet[\"temperature\"]) print(\"humidity \" + dweet[\"humidity\"]) time.sleep(10) Python中运行上述程序，之后在浏览器输入地址http://dweet.io/follow/Xavier-min-hello-world（http://dweet.io/follow/[程序中的thing_name]），即可实时访问同步至云端的数据。如下图： 单单以这种原始的方式展示数据，未免显得过于单薄无趣。好在有个东西叫做freeboard，完美地解决了这个问题。 4. ESP8266上传数据到dweet云平台硬件模块按上述接线方式连接，在Arduino IDE进行编程调试，在Arduino中关于ESP8266库的安装省略，可百度，运行代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//向物联网平台发送数据//发送数据格式： https://dweet.io/dweet/for/my-thing-name?hello=world 免费平台//my-thing-name 是自己起的地址名称；hello=world 键值对数据//获取数据 https://dweet.io/get/latest/dweet/for/my-thing-name 用网页打开#include &lt;ESP8266WiFi.h&gt;const char* ssid=\"账号\"; //家里wifi账号const char* password=\"密码\"; //wifi密码const char* host= \"dweet.io\"; //数据存储平台void setup() { Serial.begin(115200); delay(10); //接下来板子开始要连线到路由器了 Serial.println(); Serial.println(); Serial.print(\"lianjie to \"); Serial.println(ssid); WiFi.begin(ssid, password);//开始连线 while (WiFi.status() != WL_CONNECTED) { //如果没有连接成功,就输入\".\" delay(500); Serial.print(\".\"); } Serial.println(); Serial.println(\"WiFi lianxian cengong\");//输入wifi连线成功 Serial.println(WiFi.localIP());//输出IP}void loop() {delay(5000);Serial.print(\"connecting to \");Serial.println(host);WiFiClient client;//建立一个TCP客户端if (!client.connect(host,80)) //如果没有连接成功{ Serial.println(\"lianjie sibai\"); return;}//发送请求Serial.print(\"Requesting URL: \");client.print(String(\"GET /dweet/for/xavier_esp8266_link?temperature=\")+\"28\"+\"&amp;humidity=\"+\"40\"+\" HTTP/1.1\\r\\n\"+\"Host: \"+host+\"\\r\\n\"+\"Connection: close\\r\\n\\r\\n\");//xavier_esp8266_link 自己起的名字-不要跟别人重名//temperature的值是28；humidity的值是40delay(10);unsigned long timeout=millis();while(client.available()==0){ //判断是否有响应信息 if(millis()-timeout&gt;5000) //如果超时5秒，就失败 { Serial.println(\"&gt;&gt;&gt;Client Timeout!\"); client.stop(); return; }} //读取返回的信息while(client.available()){ String line=client.readStringUntil('\\r'); Serial.print(line);} //关闭连接 Serial.println(); Serial.println(\"lianjie guanbi\");} 编译，上传。打开Arduino IDE的串口监视器，显示打印信息如下： 打开MQTT服务器网页端的界面，可看到上传到MQTT服务器的温湿度数据。 5. ESP8266上传DHT11数据到dweet云平台基于上述程序和上一篇博客程序进行修改，将DHT11采集数据的程序移植进来并通过ESP8266发送到云端，理论上可实现，不做研究。","categories":[],"tags":[]},{"title":"ESP8266+DHT11+NodeRed温湿度上传MQTT","slug":"ESP8266+DHT11+NodeRed温湿度上传MQTT","date":"2021-03-01T16:55:42.383Z","updated":"2021-03-01T16:54:11.202Z","comments":true,"path":"2021/03/02/ESP8266+DHT11+NodeRed温湿度上传MQTT/","link":"","permalink":"http://xaviermin.github.io/2021/03/02/ESP8266+DHT11+NodeRed%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%B8%8A%E4%BC%A0MQTT/","excerpt":"MQTTMQTT协议是广泛应用的物联网协议，使用测试MQTT协议需要MQTT的代理。有两种方法：一是租用现成的MQTT服务器，如阿里云、华为云等云平台提供的MQTT服务，使用公用的MQTT服务器的好处是省事，但如果仅仅用于测试学习还需要注册帐号，有的平台还需要付费。另一方法是自己使用开源的MQTT组件来搭建。","text":"MQTTMQTT协议是广泛应用的物联网协议，使用测试MQTT协议需要MQTT的代理。有两种方法：一是租用现成的MQTT服务器，如阿里云、华为云等云平台提供的MQTT服务，使用公用的MQTT服务器的好处是省事，但如果仅仅用于测试学习还需要注册帐号，有的平台还需要付费。另一方法是自己使用开源的MQTT组件来搭建。 1. 准备 硬件：ESP8266（WiFi模块）、DHT11 软件：Arduino、MQTT服务器、Node-Red 2. 硬件接线 ESP8266-WiFi模块 DHT11温湿度传感器模块 VCC (3V) VCC GND GND D4 DATA (数据线) 3. 软件环境3.1 打开MQTT服务器Win10搭建MQTT服务器参考前面博客，服务器搭建好后，Win+R打开cmd窗口，cd到C盘根目录，E: -&gt; cd emqx\\bin -&gt; emqx start -&gt; cd bin -&gt; emqx_ctl status，显示如下即MQTT服务器正常运行。 emqx stop 关闭服务器 3.2 打开Node-RedNode-Red安装教程参考百度，安装好后，Win+R打开cmd窗口，执行命令node-red，显示如下即Node-Red正常运行。 浏览器中打开http://127.0.0.1:1880便可以访问Node-Red的前台界面，进行编程。 关闭cmd窗口即关闭Node-Red。 4. 温湿度数据采集并上传MQTT服务器硬件模块按上述接线方式连接，在Arduino IDE进行编程调试，在Arduino中关于ESP8266库的安装省略，可百度，运行代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;PubSubClient.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;SimpleDHT.h&gt;int pinDHT11 = 2; //esp8266用gpio2脚——D4const char* ssid=\"账号\"; //家里wifi账号const char* password=\"密码\"; //wifi密码const char* mqtt_server = \"xxx.xxx.xxx.xxx\"; //mqtt服务地址const char* clientID =\"ESP8266_DHT11\"; //设备idWiFiClient espClient;PubSubClient client(espClient);SimpleDHT11 dht11(pinDHT11);void setup() { Serial.begin(115200); setup_wifi(); client.setServer(mqtt_server,1883); client.setCallback(callback);}void setup_wifi(){ delay(10); WiFi.begin(ssid,password); //连接WiFi while(WiFi.status()!=WL_CONNECTED){ //连接不上延迟0.5秒再连 delay(500); } Serial.println(\"WiFi connected\");}//设置反馈void callback(char* topic,byte* payload, unsigned int length){ Serial.print(\"Message arrived [\"); Serial.print(topic); Serial.print(\"] \"); for (int i = 0; i &lt; length; i++) { Serial.print((char)payload[i]); } }void reconnect() { // 循环重新连接，直到连上 while (!client.connected()) { if (client.connect(clientID)) { Serial.print(\"MQTT连接成功\"); // 连接mqtt成功 client.subscribe(\"dht11_test\"); // 一旦连接，订阅主题 } else { delay(5000); } }} void loop() {if(!client.connected()){ reconnect(); } client.loop(); // start working... Serial.println(\"=================================\"); Serial.println(\"Sample DHT11...\"); // read without samples. byte temperature = 0; byte humidity = 0; int err = SimpleDHTErrSuccess; if ((err = dht11.read(&amp;temperature, &amp;humidity, NULL)) != SimpleDHTErrSuccess) { Serial.print(\"Read DHT11 failed, err=\"); Serial.println(err);delay(1000); return; } String tmp = \"temp:\"; //字符串拼接 tmp += String(temperature); tmp += String(\"humi:\"); tmp += String(humidity); Serial.print(\"Sample OK: \"); Serial.print((int)temperature); Serial.print(\" *C, \"); Serial.print((int)humidity); Serial.println(\" H\"); client.publish(\"dht11_test\",tmp.c_str()); //发送主题和内容 delay(3000);} 编译，上传。打开Arduino IDE的串口监视器，显示打印信息如下： 打开MQTT服务器网页端的界面，可看到上传到MQTT服务器的温湿度数据。 5. Node-Red显示界面Node-Red界面的显示需要以json形式的数据格式上传，所以硬件上通过ESP8266上传的数据格式需要修改，代码需要修改，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;PubSubClient.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;ArduinoJson.h&gt;#include &lt;SimpleDHT.h&gt;int pinDHT11 = 2; //esp8266用gpio2脚——D4const char* ssid=\"账号\"; //家里wifi账号const char* password=\"密码\"; //wifi密码const char* mqtt_server = \"xxx.xxx.xxx.xxx\"; //mqtt服务地址const char* clientID =\"ESP8266_DHT11\"; //设备idWiFiClient espClient;PubSubClient client(espClient);SimpleDHT11 dht11(pinDHT11);StaticJsonBuffer&lt;200&gt; jsonBuffer;JsonObject&amp; data = jsonBuffer.createObject();void setup() { Serial.begin(115200); setup_wifi(); client.setServer(mqtt_server,1883); client.setCallback(callback);}void setup_wifi(){ delay(10); WiFi.begin(ssid,password); //连接WiFi while(WiFi.status()!=WL_CONNECTED){ //连接不上延迟0.5秒再连 delay(500); } Serial.println(\"WiFi connected\");}//设置反馈void callback(char* topic,byte* payload, unsigned int length){ Serial.print(\"Message arrived [\"); Serial.print(topic); Serial.print(\"] \"); for (int i = 0; i &lt; length; i++) { Serial.print((char)payload[i]); } }void reconnect() { // 循环重新连接，直到连上 while (!client.connected()) { if (client.connect(clientID)) { Serial.print(\"MQTT连接成功\"); // 连接mqtt成功 client.subscribe(\"dht11_test\"); // 一旦连接，订阅主题 } else { delay(5000); } }} void loop() {if(!client.connected()){ reconnect(); } client.loop(); // start working... //Serial.println(\"=================================\"); Serial.println(\"DHT11 working...\"); byte temperature = 0; byte humidity = 0; //dht11.read(&amp;temperature, &amp;humidity); int err = SimpleDHTErrSuccess; if ((err = dht11.read(&amp;temperature, &amp;humidity, NULL)) != SimpleDHTErrSuccess) { Serial.print(\"Read DHT11 failed, err=\"); Serial.println(err); delay(1000); return; } data[\"temp\"] = (int)temperature; data[\"humi\"] = (int)humidity; data.printTo(Serial); char JSONmessageBuffer[100]; data.printTo(JSONmessageBuffer, sizeof(JSONmessageBuffer)); Serial.println(\"Sending message to MQTT topic..\"); Serial.println(JSONmessageBuffer); if (client.publish(\"dht11_test\", JSONmessageBuffer) == true) { Serial.println(\"Success sending message\"); } else { Serial.println(\"Error sending message\"); } //client.publish(\"dht11_test\",tmp.c_str()); //发送主题和内容 delay(3000);} 编译，上传。打开Arduino IDE的串口监视器，显示打印信息如下： Node-Red编程和界面显示： 系统正常运行！！！","categories":[],"tags":[]},{"title":"Python学习笔记（一）基础","slug":"Python学习笔记（一）基础","date":"2021-02-22T16:41:37.378Z","updated":"2021-02-22T16:40:51.966Z","comments":true,"path":"2021/02/23/Python学习笔记（一）基础/","link":"","permalink":"http://xaviermin.github.io/2021/02/23/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80/","excerpt":"PythonPython是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。","text":"PythonPython是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。 注意： 以#开头的语句是注释。 Python程序是大小写敏感的，大小写写错了程序会报错。 按照惯例，缩进是4个空格。 1. 数据类型和变量1.1 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。 1.2 浮点数浮点数也就是小数，浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 1.3 字符串字符串是以单引号'或双引号\"括起来的任意文本，比如'abc'，\"xyz\"等等。如果'本身也是一个字符，那就可以用\"\"括起来，比如\"I'm OK\"包含的字符是I，'，m，空格，O，K这6个字符。 1.4 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 1.5 变量在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。变量名必须是大小写英文、数字和_的组合，且不能用数字开头。 2. 字符串和编码由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去，其他国家语言又有其他标准，就会不可避免地出现冲突，因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 2.1 Python的字符串对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 12345678&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文' 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b'ABC' 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 1234&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文' 要计算str包含多少个字符，可以用len()函数： 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; len('中文')2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数： 123456&gt;&gt;&gt; len(b'ABC')3&gt;&gt;&gt; len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')6&gt;&gt;&gt; len('中文'.encode('utf-8'))6 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 2.2 格式化在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 常见的占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 12&gt;&gt;&gt; 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换： 1234&gt;&gt;&gt; r = 2.5&gt;&gt;&gt; s = 3.14 * r ** 2&gt;&gt;&gt; print(f'The area of a circle with radius {r} is {s:.2f}')The area of a circle with radius 2.5 is 19.62 上述代码中，{r}被变量r的值替换，{s:.2f}被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，{s:.2f}的替换结果是19.62。 3. list和tuple3.1 listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。例： 123&gt;&gt;&gt; language = ['C', 'C++', 'Python']&gt;&gt;&gt; language['C', 'C++', 'Python'] 变量language就是一个list。用len()函数可以获得list元素的个数。 用索引来访问list中每一个位置的元素，记得索引是从0开始的： 123456&gt;&gt;&gt; language[0]'C'&gt;&gt;&gt; language[1]'C++'&gt;&gt;&gt; language[2]'Python' 如果要取最后一个元素，除了计算索引位置外，可以用-1做索引，直接获取最后一个元素：classmates[-1] list是一个可变的有序表，所以，可以往list中追加元素到末尾： 123&gt;&gt;&gt; language.append('Java')&gt;&gt;&gt; language['C', 'C++', 'Python', 'Java'] 也可以把元素插入到指定的位置，比如索引号为1的位置： 123&gt;&gt;&gt; language.insert(1, 'Verilog')&gt;&gt;&gt; language['C', 'Verilog', 'C++', 'Python', 'Java'] 要删除list末尾的元素，用pop()方法。 要删除指定位置的元素，用pop(i)方法，其中i是索引位置。 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置。 3.2 tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。当定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来。没有append()，insert()这样的方法。其他获取元素的方法和list是一样的。 如果要定义一个空的tuple，可以写成t=()，只有1个元素的tuple定义时必须加一个逗号,写成t=(1，)。 4. 流程控制4.1 条件判断if的判断条件后要加:。 elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是： 12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 4.2 循环4.2.1 for…inPython的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： 123languages = ['C', 'C++', 'Python']for language in languages: print(language) 执行这段代码，会依次打印languages的每一个元素： 123CC++Python 所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。 再比如我们想计算1-10的整数之和，可以用一个sum变量做累加： 1234sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum) 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 4.2.2 while第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 4.2.3 break在循环中，break语句可以提前退出循环。 4.2.4 continue在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。 例如打印1~10的奇数： 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。 5. dict和set5.1 dictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。例： 123&gt;&gt;&gt; d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}&gt;&gt;&gt; d['Michael']95 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入： 123&gt;&gt;&gt; d['Adam'] = 67&gt;&gt;&gt; d['Adam']67 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖掉，如果key不存在，dict就会报错。要删除一个key，用pop(key)方法，对应的value也会从dict中删除： 1234&gt;&gt;&gt; d.pop('Bob')75&gt;&gt;&gt; d{'Michael': 95, 'Tracy': 85} dict内部存放的顺序和key放入的顺序是没有关系的。 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 5.2 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 要创建一个set，需要提供一个list作为输入集合： 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s{1, 2, 3} 传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，重复元素在set中自动被过滤，显示的顺序也不表示set是有序的。 通过add(key)方法可以添加元素到set中，可以重复添加，但没有效果，通过remove(key)方法可以删除元素。set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。","categories":[],"tags":[]},{"title":"Python学习笔记（二）函数","slug":"Python学习笔记（二）函数","date":"2021-02-22T16:41:37.339Z","updated":"2021-02-22T16:40:51.970Z","comments":true,"path":"2021/02/23/Python学习笔记（二）函数/","link":"","permalink":"http://xaviermin.github.io/2021/02/23/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%87%BD%E6%95%B0/","excerpt":"PythonPython是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。","text":"PythonPython是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。 1. 调用函数1.1 Python内置函数Python内置了很多有用的函数，我们可以直接调用。如： abs()：求绝对值的函数。 max()：取最大值的函数。 1.2 数据类型转换Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数。 函数名其实就是指向一个函数对象的引用，可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： 123&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1 2. 定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 2.1 空函数如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 2.2 返回多个值比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 3. 函数的参数3.1 位置参数函数power(x, n)有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。 3.2 默认参数函数power(x, n=2)，给函数参数一个固定值。 注意： 必选参数在前，默认参数在后，否则Python的解释器会报错； 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面，变化小的参数就可以作为默认参数。 3.3 可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。例： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。 3.4 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。例： 12def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 12&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: {} 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: {'city': 'Beijing'}&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'} 3.5 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 仍以person()函数为例，我们希望检查是否有city和job参数： 12345678def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw) 3.6 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 比如定义一个函数，包含上述若干种参数： 12345def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。 12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = {}&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = {}&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = {'ext': None} 3.7 小结 *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。","categories":[],"tags":[]},{"title":"Git常用命令整理笔记","slug":"Git常用命令整理笔记","date":"2021-01-28T15:00:58.346Z","updated":"2021-01-28T14:57:50.193Z","comments":true,"path":"2021/01/28/Git常用命令整理笔记/","link":"","permalink":"http://xaviermin.github.io/2021/01/28/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/","excerpt":"Git简介Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。","text":"Git简介Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。 Git常用命令表格 命令 解析 qwd 显示当前目录的路径 git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件 git add xxx 把xxx文件添加到暂存区去 git commit –m ‘xxx’ 提交文件，–m 后面的是提交说明 git status 查看仓库状态 git diff xxx 查看xxx文件修改了那些内容 git log 查看历史记录 git log –oneline 查看历史记录，显示一行 git reflog 查看历史记录的版本号id git reset –hard HEAD~ 回退到上一个版本 git reset –hard HEAD~100 回退到100个版本 cat xxx 查看xxx文件内容 git checkout – xxx 把xxx文件在工作区的修改全部撤销 git rm xxx 删除xxx文件 git remote add origin https://github.com… 关联一个远程库 git clone https://github.com 从远程库中克隆 git push origin master 把当前master分支推送到远程库 git checkout –b dev 创建dev分支，并切换到dev分支上 git branch 查看当前所有的分支 git checkout 分支名 切换到xxx分支 git merge dev 在当前的分支上合并dev分支 git branch –d dev 删除dev分支 git branch name 创建分支 git stash 把当前的工作隐藏起来，等以后恢复现场后继续工作 git stash list 查看所有被隐藏的文件列表 git stash apply 恢复被隐藏的文件，但是内容不删除 git stash drop 删除文件 git stash pop 恢复文件的同时，也删除文件 git remote 查看远程库的信息 git remote –v 查看远程库的详细信息 git push origin master 把master分支推送到远程库对应的远程分支上 git fetch origin 从远程拉取数据到本地 Git删除指定commit git log 查看已提交的记录，找到要删除的 commit 找到此次提交之前的一次提交 commit-id 执行 git rebase -i xxx(commit-id) 按i进入编辑模式，将要删除的 commit 的pick改成drop 再执行git log，查看提交记录，已删除 根据 commit-id 查询包含该提交 id 的所有分支 查本地所有分支 git branch –contains commit-id 查远程所有分支 git branch -r –contains commit-id 查本地和远程所有分支 git branch -a –contains commait-id git commit 常用命令解析 git commit -m ‘提交信息’ git commit -a -m ‘提交信息’ -a 可以把还没有执行add命令的修改一起提交 git commit –amend 修改上一次的提交信息；可以将最近的修改追加到上一次的提交上 Git恢复修改后的文件 只修改了文件，没有任何git操作 git checkout – xxx xxx为文件名 修改了文件，并提交到暂存区（即编辑之后，git add但没有git commit -m） git log –oneline git reset HEAD 回退到当前版本 git checkout – xxx 修改了文件，并提交了仓库区（即编辑之后，git add和git commit -m） git log –oneline git reset HEAD~ 回退到上一版本 git checkout – xxx","categories":[],"tags":[]},{"title":"STM32+ESP8266+DHT11温湿度上传OneNet","slug":"STM32+ESP8266+DHT11温湿度上传OneNet","date":"2020-10-27T12:17:31.204Z","updated":"2020-10-27T12:23:01.845Z","comments":true,"path":"2020/10/27/STM32+ESP8266+DHT11温湿度上传OneNet/","link":"","permalink":"http://xaviermin.github.io/2020/10/27/STM32+ESP8266+DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%B8%8A%E4%BC%A0OneNet/","excerpt":"OneNetOneNET是由中国移动打造的PaaS物联网开放平台。平台能够帮助开发者轻松实现设备接入与设备连接，快速完成产品开发部署，为智能硬件、智能家居产品提供完善的物联网解决方案。OneNET针对个人用户免费，虽然有接入数量的限制，但不影响我们学习，登录OneNET官网进行注册登录并实名认证，方便后续使用。","text":"OneNetOneNET是由中国移动打造的PaaS物联网开放平台。平台能够帮助开发者轻松实现设备接入与设备连接，快速完成产品开发部署，为智能硬件、智能家居产品提供完善的物联网解决方案。OneNET针对个人用户免费，虽然有接入数量的限制，但不影响我们学习，登录OneNET官网进行注册登录并实名认证，方便后续使用。 1. 准备 硬件：正点原子探索者开发板（STM32F407）、ATK-ESP8266-V1.3（WiFi模块）、USB转TTL模块、DHT11 软件：正点原子8266固件、固件下载工具、串口调试助手、Keil5 2. 固件下载接线 WiFi模块 USB-TTL模块 VCC VCC(+5V) GND GND TXD RXD RXD TXD RST 不接 IO_0 GND(烧录固件库接地，联网时不接) GND和IO_0一定要共地连接，不然烧写不成功。 烧写工具和固件位置如下 双击打开ESP_DOWNLOAD_TOOL_V2.4.exe应用程序，配置如下，点击START进行烧录 烧录完成后插入STM32F407开发板相应接口即可，同样DHT11温湿度传感器也插入相应接口。 3. 配置云端进入OneNET官网，点击控制台。 选择多协议接入 点击添加产品，填写产品信息，这里我已经创建好了，所选配置如下 创建完成，这里的产品ID后续程序中要用到 点击创建的产品，设备列表-&gt;添加设备 填写设备信息，这里的鉴权信息注意一下，后面程序要用到，我设置的设备名称和鉴权信息相同 添加完成状态如下，显示离线，设备ID后续程序也要用到 至此云端配置完成，下面看程序。 4. 软件程序工程结构如下，ESP8266模块用到的是开发板上的串口3，onenet.c用于和OneNet平台之间的数据交互，程序我还没仔细看，感觉这个应该是发送数据上云的重点部分，加关注！！MqttKit.c应该是MQTT工具包，MQTT是一种通信协议，可以先不管，这里是直接拿过来用，eap8266.c是ESP8266的简单驱动和初始化。 需要修改的地方有，这里改成你们自己的WiFi名称和密码 这里改成前面强调的三个信息，根据前面创建的信息修改 配置完成，烧写程序到开发板上。 配置完成后，电脑连上设备，选择正确的端口号和波特率，点击START开始烧入。 进度条走完，显示FINSH，固件下载成功。 5. 显示结果正常的话，屏幕上可以显示温湿度 打开串口调试助手，可看到以下信息 回到OneNet云端，设备显示在线 点击数据流，可查看ESP8266上传的温湿度数据 设备正常运行，大家接着进行后续开发吧！！！","categories":[],"tags":[]},{"title":"ESP8266连接原子云","slug":"ESP8266连接原子云","date":"2020-10-25T15:01:48.037Z","updated":"2020-10-25T15:00:22.528Z","comments":true,"path":"2020/10/25/ESP8266连接原子云/","link":"","permalink":"http://xaviermin.github.io/2020/10/25/ESP8266%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%AD%90%E4%BA%91/","excerpt":"利用正点原子的ESP8266模块接入原子云原子云即原子云服务器，是ALIENTEK（正点原子）推出的物联网云服务平台，它可以实现数据的远程监控、转发和管理等功能。原子云域名为：cloud.alientek.com，端口号为：59666。之前有做过ESP8266接入阿里云，今天才知道正点原子自己有个云服务器，买的也是正点原子的WiFi模块，连接就很方便，以后有时间学习学习ESP8266接入机智云。","text":"利用正点原子的ESP8266模块接入原子云原子云即原子云服务器，是ALIENTEK（正点原子）推出的物联网云服务平台，它可以实现数据的远程监控、转发和管理等功能。原子云域名为：cloud.alientek.com，端口号为：59666。之前有做过ESP8266接入阿里云，今天才知道正点原子自己有个云服务器，买的也是正点原子的WiFi模块，连接就很方便，以后有时间学习学习ESP8266接入机智云。 1. 准备 硬件：正点原子ATK-ESP8266-V1.3（WiFi模块）、USB转TTL模块 软件：正点原子8266固件、固件下载工具、串口调试助手软件资料链接：https://pan.baidu.com/s/1N5VzGeASDSheq2zExkN4Iw 提取码：8266 2. 接线 WiFi模块 USB-TTL模块 VCC VCC(+5V) GND GND TXD RXD RXD TXD RST 不接 IO_0 GND(烧录固件库接地，联网时不接) 3. 配置云端进入原子云官网，点击设备管理-&gt;新增设备。 设置设备名称和密码，这里我设成名称ESP8266_test，密码默认12345678。 点击新增后，在设备管理中能看到刚创建的设备，点击编辑设备，这里的设备编号和密码后面操作会用到。 4. 8266固件下载打开flash_download_tools_v3.6.3固件下载工具，选择ESP8266 DownloadTool，选择下载好的原子云8266模块固件并设置好下载地址，其他配置如图所示。 这里下载要注意一个问题，WiFi模块上的IO_0引脚要接地，而且要和GND共地连接，不然下载不成功。 配置完成后，电脑连上设备，选择正确的端口号和波特率，点击START开始烧入。 进度条走完，显示FINSH，固件下载成功。 5. 联网测试固件成功后，拔掉IO_0引脚的连接线，才可正常测试，打开串口调试助手，准备好如下AT指令。 1234AT+CWMODE=1AT+RSTAT+CWJAP=\"TP-LINK_531\",\"zhoulianying531\"AT+ATKCLDSTA=\"49877501422779183959\",\"12345678\" 打开串口，给WiFi模块重新上电，会显示如下信息。 依次发送AT指令 显示CLOUD CONNECTED，表示连接成功，回到原子云官网查看，显示已连接。 下面进行测试 设备正常运行，原子云连接成功！！！","categories":[],"tags":[]},{"title":"专利交底书内容","slug":"专利交底书内容","date":"2020-10-02T02:40:07.804Z","updated":"2020-11-27T03:13:19.900Z","comments":true,"path":"2020/10/02/专利交底书内容/","link":"","permalink":"http://xaviermin.github.io/2020/10/02/%E4%B8%93%E5%88%A9%E4%BA%A4%E5%BA%95%E4%B9%A6%E5%86%85%E5%AE%B9/","excerpt":"技术交底书技术交底书是专利代理人理解技术方案的重要依据，是撰写专利法律文件的基础。申请人在委托专利代理公司代理专利申请业务时，需要向专利代理公司提交技术交底书，一份好的专利技术交底书可以使代理人快速理解技术方案，可以缩短后续发明人与代理人沟通的时间，加快案件撰写的进度。技术交底书是专利代理人撰写专利法律文件的第一手技术材料，是给代理人看的。专利代理人是专利法律专家，熟知专利撰写的相关技巧；而不是技术专家，与发明人在专业技术方面有较大的差距。","text":"技术交底书技术交底书是专利代理人理解技术方案的重要依据，是撰写专利法律文件的基础。申请人在委托专利代理公司代理专利申请业务时，需要向专利代理公司提交技术交底书，一份好的专利技术交底书可以使代理人快速理解技术方案，可以缩短后续发明人与代理人沟通的时间，加快案件撰写的进度。技术交底书是专利代理人撰写专利法律文件的第一手技术材料，是给代理人看的。专利代理人是专利法律专家，熟知专利撰写的相关技巧；而不是技术专家，与发明人在专业技术方面有较大的差距。 1. 发明名称简单、准确地表明发明创造专利申请请求保护的主题和类型，一般不得超过25个字,不要含有人名、单位名、商标、代号和型号等非技术术语 2. 技术领域说明发明或实用新型技术方案所属或直接应用的具体技术领域 3. 背景技术此部分简要说明别人做的有什么缺陷？需要客观说明各背景技术的方法或产品在工艺或性能上的不足。从现有产品结构出发，客观地阐述现有产品存在的缺陷（如结构复杂、制造成本高、使用不便、精度不高等等），在此段落中可以罗列尽可能多的缺陷。（注：需从产品结构出发，不能主观臆测，也不能笼统地说明） 4. 发明内容（必填）4.1 要解决的技术问题（必填）针对现有技术存在的技术问题，提出本发明要解决的技术问题。（可以从背景技术中总结、摘要） 4.2 技术方案（必填）此部分详细说明我是怎么做的？需要详细说明本发明的总体技术方案，即从若干次研发试验结果总结出来的技术方案。此部分是交底书的核心，需要对结构组成、方法步骤、条件参数、技术手段、技术方案、产品结构特征等进行十分详细地说明，阐述如下几点：1、产品的结构、各部件的位置、部件间的相互关系；2、各部件的作用、形状、位置及连接关系；3、各部件如何配合本发明所述优点。4、工艺流程的优化、配置、作用。若有可替换的部件或其它相接近的技术方案，请进行描述并说明原理。 4.3 有益效果（必填）此部分详细说明我做的有哪些优点？需要详细阐述本发明所达到的效果和优点。可以用产量、品质、收率产率、质量、精度、效率提高，能耗、原材料、工序的节省，加工、操作、控制、使用的简便，有利于环保、降低劳动强度，出现有用性能等的数据说明。最好与背景技术比较，用实验数据来说明发明效果；也可以从理论推导或特点分析来说明发明效果。当采用实验数据时，应给出必要的试验条件和方法 5. 附图及附图说明（必填）提供能反映本发明技术方案的必要附图，对图中的零部件，标示相应标号，必要时也可提供有关现有技术附图。图要是黑白的线条图，不能有其他颜色。 6. 具体实施方式（可以根据技术方案总结、修改、补充）详细描述申请人认为实现发明或实用新型的优选的具体实施方式，适当情况下，应当举例说明，有附图的，应当对照附图。应当体现申请中解决技术问题所采用的技术方案，并对技术方案中的技术特征给予详细说明，使本领域的技术人员按照所描述的内容能够重现发明或实用新型，不必再花费创造性劳动。 学校专利申请流程 1申请资料发送至 31418367@qq.com 邮箱。 专利检索网站： 佰腾网 润桐RainPat专利检索 大为innojoy专利搜索引擎 参考博客： 关于写专利（专利交底书） 专利秘籍分享：如何撰写专利技术交底书？交底书中有哪些坑？ 如何撰写技术交底书","categories":[],"tags":[]},{"title":"VMware安装Ubuntu16.04","slug":"VMware安装Ubuntu16.04","date":"2020-09-30T06:57:27.956Z","updated":"2020-09-30T02:54:53.669Z","comments":true,"path":"2020/09/30/VMware安装Ubuntu16.04/","link":"","permalink":"http://xaviermin.github.io/2020/09/30/VMware%E5%AE%89%E8%A3%85Ubuntu16.04/","excerpt":"VMware简介VMware Workstation（中文名“威睿工作站”）是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。VMware Workstation可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。对于企业的 IT开发人员和系统管理员而言， VMware在虚拟网路，实时快照，拖曳共享文件夹，支持 PXE 等方面的特点使它成为必不可少的工具。","text":"VMware简介VMware Workstation（中文名“威睿工作站”）是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。VMware Workstation可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。对于企业的 IT开发人员和系统管理员而言， VMware在虚拟网路，实时快照，拖曳共享文件夹，支持 PXE 等方面的特点使它成为必不可少的工具。 1. 软件环境 Windows-10-64bit VMware-workstation-full-12.1.0-3272444.exe ubuntu16.04_64位 ubuntu-16.04.7-desktop-amd64.iso（镜像文件） 2.安装VMware-workstation 12双击运行VMware-workstation-full-12.1.0-3272444.exe 勾选接收许可协议条款，下一步 修改安装目录 取消启动是检查产品更新，下一步 默认，下一步，安装 完成安装 打开桌面的VMware，初次安装需要注册，选择许可证密钥，将密钥.txt中的密钥填进去 注册完成 显示界面 3.安装Ubuntu16.04打开VMware，点击文件-&gt;新建虚拟机 选择自定义，下一步 默认，下一步 选择稍后安装操作系统, 也可以选择第二项，下一步 选择Linux，版本选择Ubuntu 64位，这里可能遇到一个问题，此主机不支持64位客户机操作系统，此系统无法运行。 解决办法： 以管理员身份运行cmd，然后执行命令bcdedit /set hypervisorlaunchtype off，执行完后重启计算机即可解决。 更改虚拟机系统存放位置，不要放C盘 这里根据自己电脑配置选择, 处理器数量: 核心数；内核数量: 线程 内存同样按照一半来配置,可根据自身主要使用哪个系统(PC/虚拟机)来进行配置 网络连接方式使用默认的即可, 后期有需要可在”虚拟机”-&gt;”设置”中更改 默认，下一步 指定磁盘大小，可修改，也可默认 默认，完成 4.配置点击标签页中的编辑虚拟机设置 把之前下载好的镜像文件添加到这里 启动虚拟机 选择English，点击Install Ubuntu 这里询问是否安装更新，这里不勾选，直接Continue 由于是新的虚拟机，选择删除磁盘并安装 这里选择Continue 选择地区，没有影响，默认 这里的键盘布局，默认 设置你的密码和用户名，用户名用英文，密码用字母 安装中… 现在重启 如果按下”现在重启”后卡在了黑底命令符那里(大概1-2分钟)不动的话， 强制重启（可以解决很多问题） 如果鼠标在虚拟机中移不出来, 按下键盘的CTRL+ALT即可。 输入登录密码 重启之后，发现Ubuntu界面过小 解决办法是：System Settings-&gt;Displays-&gt;1680x1050(16:10) 安装完成","categories":[],"tags":[]},{"title":"安装Ubuntu16.04后要做的事儿","slug":"安装Ubuntu16.04后要做的事儿","date":"2020-09-30T06:57:27.899Z","updated":"2020-09-30T06:56:42.497Z","comments":true,"path":"2020/09/30/安装Ubuntu16.04后要做的事儿/","link":"","permalink":"http://xaviermin.github.io/2020/09/30/%E5%AE%89%E8%A3%85Ubuntu16.04%E5%90%8E%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E5%84%BF/","excerpt":"优化Ubuntu 16.04带来了很多新特性，同样也依然带着很多不习惯的东西，所以装完系统后还要进行一系列的优化。本篇文章主要介绍了安装Ubuntu 16.04后要做的事，安装一些工具和软件，卸载一些没用的东西，有兴趣的可以了解一下。","text":"优化Ubuntu 16.04带来了很多新特性，同样也依然带着很多不习惯的东西，所以装完系统后还要进行一系列的优化。本篇文章主要介绍了安装Ubuntu 16.04后要做的事，安装一些工具和软件，卸载一些没用的东西，有兴趣的可以了解一下。 1. 删除Amazon的链接1sudo apt-get remove unity-webapps-common 2. 安装Vim居然默认没有集成Vim神器，只能手动安装了。 1sudo apt-get install vim 3. 安装谷歌浏览器Ubuntu界面中打开自带的火狐浏览器，输入Chrome浏览器的网址https://www.google.cn/chrome/，点击**下载Chrome**字样，弹出下载提示信息，直接选择接受并安装即可。 在点击接受下载之后，会弹出下载保存的提示，会默认下载完成到home下的Downloads文件夹中，下载完成之后，双击安装包进行安装，也可使用dpkg相关的命令进行安装。 成功安装之后，打开终端输入google-chrome命令，回车启动Chrome浏览器，接着会弹出提示窗口，可以根据自己的需求选择是否打钩，点击弹窗提示的确定按钮即可打开Chrome浏览器。再打开chrome浏览器之后，建议锁定到启动栏，这样方便以后大家的使用，不用再使用命令启动。 4. 安装搜狗输入法在谷歌浏览器中搜索搜狗输入法for Linux，双击安装包进行安装 5. 安装git和vpncgit和vpn大家都懂的，程序员的好工具。 1sudo apt-get install vpnc git 6. 安装CMake和Qt CreatorCMake和Qt Creator是Linux下开发C++程序的神器，Ubuntu 15.04已经集成了最新版的Qt Creator （3.1.1）。 1sudo apt-get install cmake qtcreator","categories":[],"tags":[]},{"title":"图像识别参考博客","slug":"图像识别参考博客","date":"2020-09-28T08:57:55.559Z","updated":"2020-09-28T08:57:56.457Z","comments":true,"path":"2020/09/28/图像识别参考博客/","link":"","permalink":"http://xaviermin.github.io/2020/09/28/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"参考博客 Qt+opencv部署深度学习模型到windows与android Qt+opencv dnn模块调用tensorflow模型 OpenCV调用TensorFlow预训练模型 Qt+opencv+EasyPR（车牌识别系统） Qt 使用摄像头通过openCV进行人脸识别","categories":[],"tags":[]},{"title":"Qt5.12.9+Cmake3.18.3编译OpenCV3.4","slug":"Qt5.12.9+Cmake3.18.3编译OpenCV3.4","date":"2020-09-28T06:36:16.053Z","updated":"2020-09-28T06:40:59.287Z","comments":true,"path":"2020/09/28/Qt5.12.9+Cmake3.18.3编译OpenCV3.4/","link":"","permalink":"http://xaviermin.github.io/2020/09/28/Qt5.12.9+Cmake3.18.3%E7%BC%96%E8%AF%91OpenCV3.4/","excerpt":"Cmake简介CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile ），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。","text":"Cmake简介CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile ），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。 OpenCV是一个跨平台的计算机视觉库，使用前需要把它编译成二进制的静态库和动态库，之后在代码中直接连接到二进制库。 1. 软件环境 Windows-10-64bit MinGW-x64-4.8.1-release-posix-seh-rev5 cmake-3.18.3-win64-x64.msi（最新版本） OpenCV3.4.1（前面安装过） Qt5.12.9 Python37 2.安装Qt5.12.9并配置环境前面安装好的Qt版本是5.14.2，参考博客VS2017+Qt5.14.2环境搭建，mingw730_64的版本，但在cmake编译过程中出现莫名其妙的错误，百度无解…换成5.12.9版本，编译通过并且测试Qt没问题，卸载当前版本并安装Qt5.12.9（安装教程），安装完成后将QT安装路径的G:\\Qt\\Qt\\5.14.2\\Tools\\mingw730_64\\bin添加到环境变量Path路径当中。 3.安装Cmake3.18.3可以安装最新版本，安装成功之后，添加环境变量Path路径D:\\InstallationPath\\CMake\\bin，Cmake的安装路径最好不要有中文或空格。 4.安装 MinGW-w64 并配置环境变量使用 MinGW-x64-4.8.1 版本，为用户变量 Path 添加 D:\\InstallationPath\\mingw64\\bin。 5.安装Python编译过程中好像是需要Python环境，我之前就在电脑上装过，在弄这个的时候没管Python环境，最好先装好Python，教程参考网上的，有很多。 6.使用 CMake 生成 OpenCV 的 Makefile6.1 准备工作保证环境变量Path要有以下路径值： 改动源文件： 修改 G:\\OpenCV\\opencv\\sources\\3rdparty\\protobuf\\src\\google\\protobuf\\stubs\\io_win32.cc文件，将第94行的nullptr改为NULL。 修改G:\\OpenCV\\opencv\\sources\\modules\\photo\\test\\test_hdr.cpp文件，增加头文件包含 #include &lt;ctime&gt;和#include &lt;cstdlib&gt;。 在放置OpenCV的源文件位置新建一个文件夹opencv_build，用来放置编译后生成的源码文件。 6.2 编译配置打开安装好的Cmake，设置源码和生成路径： Where is the source code: G:/OpenCV/opencv/sources Where to build the binaries: G:/OpenCV/opencv_build 点击 Configure，设置编译器，步骤如下： Specify the generator for this project: MinGW Makefiles Specify native compilers Next Compilers C: D:\\InstallationPath\\mingw64\\bin\\gcc.exe Compilers C++: D:\\InstallationPath\\mingw64\\bin\\g++.exe Finish 等待Configure完成，设置编译选项： 确保勾选：WITH_OPENGL、WITH_QT、ENABLE_CXX11取消勾选：WITH_MSMF、WITH_IPP、ENABLE_PRECOMPILED_HEADERS 点击 Configure，Generate 生成 Makefile 配置完成信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107General configuration for OpenCV 3.4.1 ===================================== Version control: unknown Platform: Timestamp: 2020-09-28T03:16:16Z Host: Windows 10.0.18362 AMD64 CMake: 3.18.3 CMake generator: MinGW Makefiles CMake build tool: C:/Windows/System32/mingw32-make.exe Configuration: Release CPU/HW features: Baseline: SSE SSE2 SSE3 requested: SSE3 Dispatched code generation: SSE4_1 SSE4_2 FP16 AVX AVX2 requested: SSE4_1 SSE4_2 AVX FP16 AVX2 AVX512_SKX SSE4_1 (3 files): + SSSE3 SSE4_1 SSE4_2 (1 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 (2 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 AVX AVX (5 files): + SSSE3 SSE4_1 POPCNT SSE4_2 AVX AVX2 (9 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 FMA3 AVX AVX2 C/C++: Built as dynamic libs?: YES C++11: YES C++ Compiler: D:/InstallationPath/mingw64/bin/g++.exe (ver 4.8.1) C++ flags (Release): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wuninitialized -Winit-self -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG -DNDEBUG C++ flags (Debug): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wuninitialized -Winit-self -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -fvisibility-inlines-hidden -g -O0 -DDEBUG -D_DEBUG C Compiler: D:/InstallationPath/mingw64/bin/gcc.exe C flags (Release): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wuninitialized -Winit-self -Wno-narrowing -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -O3 -DNDEBUG -DNDEBUG C flags (Debug): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wuninitialized -Winit-self -Wno-narrowing -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -g -O0 -DDEBUG -D_DEBUG Linker flags (Release): -Wl,--gc-sections Linker flags (Debug): -Wl,--gc-sections ccache: NO Precompiled headers: NO Extra dependencies: opengl32 glu32 3rdparty dependencies: OpenCV modules: To be built: calib3d core dnn features2d flann highgui imgcodecs imgproc java_bindings_generator ml objdetect photo shape stitching superres ts video videoio videostab Disabled: js python3 python_bindings_generator world Disabled by dependency: - Unavailable: cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev java python2 viz Applications: tests perf_tests apps Documentation: NO Non-free algorithms: NO Windows RT support: NO GUI: QT: YES (ver 5.12.9) QT OpenGL support: YES (Qt5::OpenGL 5.12.9) Win32 UI: YES OpenGL support: YES (opengl32 glu32) VTK support: NO Media I/O: ZLib: build (ver 1.2.11) JPEG: build (ver 90) WEBP: build (ver encoder: 0x020e) PNG: build (ver 1.6.34) TIFF: build (ver 42 - 4.0.9) JPEG 2000: build (ver 1.900.1) OpenEXR: build (ver 1.7.1) Video I/O: Video for Windows: YES DC1394: NO FFMPEG: YES (prebuilt binaries) avcodec: YES (ver 57.107.100) avformat: YES (ver 57.83.100) avutil: YES (ver 55.78.100) swscale: YES (ver 4.8.100) avresample: YES (ver 3.7.0) GStreamer: NO DirectShow: YES Parallel framework: none Trace: YES (built-in) Other third-party libraries: Lapack: NO Eigen: NO Custom HAL: NO Protobuf: build (3.5.1) NVIDIA CUDA: NO OpenCL: YES (no extra features) Include path: G:/OpenCV/opencv/sources/3rdparty/include/opencl/1.2 Link libraries: Dynamic load Python (for build): D:/Program Files (x86)/Python/Python37/python.exe Java: ant: NO JNI: C:/Program Files/Java/jdk1.8.0_131/include C:/Program Files/Java/jdk1.8.0_131/include/win32 C:/Program Files/Java/jdk1.8.0_131/include Java wrappers: NO Java tests: NO Matlab: NO Install to: G:/OpenCV/opencv_build/installConfiguring doneGenerating done 6.3 开始编译和安装OpenCV库接下来将是最头疼的事情，困扰了我四天……太难受了 以管理员方式打开cmd，定位到opencv_build目录下，或者在opencv_build文件夹中按住Shift点击鼠标右键，点击在此处打开Powershell窗口。 执行命令：mingw32-make -j 8 不出意外在编译过程中肯定会出错，下面记录我在编译过程中遇到的三个错误，如果遇到其他错误自行百度。 1.MinGW-w64 的 aviriff.h 文件注释错误12345678910111213141516171819[ 49%] Building CXX object modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.objIn file included from E:\\opencv_341\\opencv\\sources\\modules\\videoio\\src\\cap_dshow.cpp:113:0:e:\\mingw-w64\\x64-4.8.1-release-posix-seh-rev5\\mingw64\\x86_64-w64-mingw32\\include\\aviriff.h:2:8: error: expected constructor, destructor, or type conversion before 'file' * This file is part of the mingw-w64 runtime package. ^e:\\mingw-w64\\x64-4.8.1-release-posix-seh-rev5\\mingw64\\x86_64-w64-mingw32\\include\\aviriff.h:3:25: error: 'refer' does not name a type * No warranty is given; refer to the file DISCLAIMER within this package. ^In file included from e:\\mingw-w64\\x64-4.8.1-release-posix-seh-rev5\\mingw64\\x86_64-w64-mingw32\\include\\aviriff.h:19:0, from E:\\opencv_341\\opencv\\sources\\modules\\videoio\\src\\cap_dshow.cpp:113:e:\\mingw-w64\\x64-4.8.1-release-posix-seh-rev5\\mingw64\\x86_64-w64-mingw32\\include\\pshpack2.h:7:21: error: expected declaration before end of line #pragma pack(push,2) ^modules\\videoio\\CMakeFiles\\opencv_videoio.dir\\build.make:146: recipe for target 'modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj' failedmingw32-make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj] Error 1CMakeFiles\\Makefile2:3057: recipe for target 'modules/videoio/CMakeFiles/opencv_videoio.dir/all' failedmingw32-make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2Makefile:161: recipe for target 'all' failedmingw32-make: *** [all] Error 2 解决： 打开D:\\InstallationPath\\mingw64\\x86_64-w64-mingw32\\include\\aviriff.h文件，发现第一行的多行注释少了个/符号，加上保存，如下： 1234/*** This file is part of the mingw-w64 runtime package.* No warranty is given; refer to the file DISCLAIMER within this package.*/ 然后重新 Configure-Generate-mingw32-make 就好了。 2.具体错误信息没有记录下来，关于G:\\OpenCV\\opencv\\sources\\modules\\python\\src2\\cv2.cpp文件的错误，修改的地方如下，前面加上个（char *） 3.问题：cmath:1097:11: error: ‘::hypot’ has not been declared 百度了好久，导致问题的原因说是hypot被某段代码重命名为了 _hypot，致使cmath调用hypot的时候无法找到，按照给出的解决办法照做，但没用……再百度，取消勾选这两项，然后重新Configure和Generate。 问题解决 最终编译完成，100% 然后执行命令：mingw32-make install，完成安装。 把如下路径添加到Path环境变量中 7.验证在QT中使用opencv打开Qt，新建项目 创建项目名称，选择项目保存路径，下一步 默认，下一步 默认（也可修改），下一步 选择Desktop Qt 5.12.9 MinGW 64-bit，下一步 默认，完成 在.pro文件中的底部添加以下内容（根据自己的安装路径，自行修改）： 1234INCLUDEPATH+=G:\\OpenCV\\opencv\\build\\include G:\\OpenCV\\opencv\\build\\include\\opencv G:\\OpenCV\\opencv\\build\\include\\opencv2LIBS += G:\\OpenCV\\opencv_build\\lib\\libopencv_*.a 修改main.cpp中代码： 12345678910111213#include &lt;opencv2/opencv.hpp&gt;using namespace cv;int main(){ Mat image; image=imread(\"G:\\\\1.jpg\"); //括号里更改为自己图像的路径 namedWindow(\"显示\"); imshow(\"显示\",image); waitKey(0); return 0;} 然后编译运行","categories":[],"tags":[]},{"title":"VS2010+Qt5.1.1环境搭建","slug":"VS2010+Qt5.1.1环境搭建","date":"2020-09-22T08:59:11.647Z","updated":"2020-09-22T08:57:17.949Z","comments":true,"path":"2020/09/22/VS2010+Qt5.1.1环境搭建/","link":"","permalink":"http://xaviermin.github.io/2020/09/22/VS2010+Qt5.1.1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"Qt简介Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，Qt很容易扩展，并且允许真正地组件编程。基本上，Qt 同 [X Window](https://baike.baidu.com/item/X Window) 上的 Motif，Openwin，GTK 等图形界面库和 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。","text":"Qt简介Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，Qt很容易扩展，并且允许真正地组件编程。基本上，Qt 同 [X Window](https://baike.baidu.com/item/X Window) 上的 Motif，Openwin，GTK 等图形界面库和 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。 1. 所需软件 VS2010（安装教程自行百度） Qt安装包：qt-windows-opensource-5.1.1-msvc2010-x86-offline.exe Qt插件：qt-vs-addin-1.2.4-opensource.exe 2.下载Qt5.1.1及Qt插件2.1 下载Qt5.1.1推荐直接下载离线版的安装程序，简洁明了。 Qt安装包下载网址：http://download.qt.io/archive/qt/ 找到对应的版本进行下载，里面包含多种不同的版本，MSVC2010、MSVC2012分别是指支持VS2010与VS2012的Qt版本，opengl与非opengl的区别是是否支持opengl，Android、iOS分别指支持android、ios平台的Qt版本。 2.2 下载Qt插件Qt插件下载网址：https://download.qt.io/official_releases/vsaddin/ 我选择了1.2.4版本 3.安装及配置环境变量 Qt及其插件的安装顺序没什么要求，根据安装程序提示安装即可，先安装Qt后安装插件。 安装完成后，打开VS2010，上面的菜单栏会出现Qt5的选项。 在系统环境变量中添加QTDIR，修改值为你的QT环境安装地址。 为了防止可执行程序直接运行出现丢失*.dll的情况，在系统环境变量PATH中添加包含dll文件的路径 。 配置Visual Studio 2010的开发环境，打开VS2010，选择Qt5-&gt;QtOptions-&gt;Add，配置VS的开发环境。 10 4.测试打开 vs2010，选择文件-&gt;新建-&gt;项目。 点击此处的.ui文件 页面就会跳到Qt 界面，然后选择 label 将其拖动到中间的窗口，然后保存 ，切记保存。 返回vs2010的页面，先保存一下，然后按键Ctrl+F5进行调试，当弹出这个窗口则表示以上所有环节均配置成功。 OK！配置完成！！！","categories":[],"tags":[]},{"title":"VS2017+Qt5.14.2环境搭建","slug":"VS2017+Qt5.14.2环境搭建","date":"2020-09-22T04:29:28.912Z","updated":"2020-09-22T04:25:55.329Z","comments":true,"path":"2020/09/22/VS2017+Qt5.14.2环境搭建/","link":"","permalink":"http://xaviermin.github.io/2020/09/22/VS2017+Qt5.14.2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"Qt简介Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，Qt很容易扩展，并且允许真正地组件编程。基本上，Qt 同 [X Window](https://baike.baidu.com/item/X Window) 上的 Motif，Openwin，GTK 等图形界面库和 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。","text":"Qt简介Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，Qt很容易扩展，并且允许真正地组件编程。基本上，Qt 同 [X Window](https://baike.baidu.com/item/X Window) 上的 Motif，Openwin，GTK 等图形界面库和 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。 1. 所需软件 VS2017（安装教程自行百度） Qt安装包：qt-opensource-windows-x86-5.14.2.exe Qt插件：qt-vsaddin-msvc2017-2.2.1.vsix 2.下载Qt5.14.2及Qt插件2.1 下载Qt5.14.2推荐直接下载离线版的安装程序，简洁明了。 Qt安装包下载网址：http://download.qt.io/archive/qt/ 我选择了最新的5.14.2版本 2.2 下载Qt插件Qt插件下载网址：https://download.qt.io/official_releases/vsaddin/ 我选择了2.2.1版本（for VS2017） 3.安装Qt并与VS2017相关联 双击下载好的安装包，点击Next。 这里需要登录Qt账号，如果没有账号在下面sign up中注册一个或者进Qt官网注册。 勾选已阅读，下一步。 下一步 更改安装目录，下一步 选择安装的组件，首先点击展开 Qt 5.14.2， tools组件这里默认即可 在展开的组件中，按照自己安装的VS版本 进行选择，这里以VS2017 -64位为例，除了图片上勾选的组件之外，如果需要其他的请自行勾选，然后选择下一步 接受协议，然后下一步 可以不改，默认即可，下一步 点击安装即可 安装完成 打开VS2017，选择工具-&gt;扩展和更新 点击联机，然后在搜索框中输入Qt ，点击 下载 下载完成之后，点击 关闭，关闭VS2017，就会弹出以下安装界面，点击 修改。 Qt VS tools会自动安装，安装完成之后点击 关闭，再次打开vs2017，标题栏会出现 Qt VS tools，同时选择 文件 - &gt;新建 - &gt;项目 中也会出现Qt的选项。 4.环境变量的配置在VS2017 的 Qt vs tools 的下拉菜单中选择 Qt options。 选择 Add 选项，添加路径。 找到Qt安装路径下的 msvc2017_64的路径，添加到Path。 配置电脑的环境变量，然后点击新建按钮，将刚才的msvc2017_64下面的bin 路径添加进去即可；然后全部确定退出即可。 5.测试有个问题，上面在VS2017里安装的Qt插件，在新建项目的时候没有Qt GUI Application一项，原因是安装的插件的不同，先卸载现有的Qt插件，去官网下载其他版本的插件，博客开头有下载插件的说明。 打开 vs2017，选择文件-&gt;新建-&gt;项目。 点击此处的.ui文件 页面就会跳到Qt 界面，然后选择 label 将其拖动到中间的窗口，然后保存 ，切记保存。 返回vs2017的页面，先保存一下，然后按键Ctrl+F5进行调试，当弹出这个窗口则表示以上所有环节均配置成功。 OK！配置完成！！！","categories":[],"tags":[]},{"title":"VS2017+OpenCV3.4实现人脸识别","slug":"VS2017+OpenCV3.4实现人脸识别","date":"2020-09-16T09:32:34.144Z","updated":"2020-09-16T09:31:52.910Z","comments":true,"path":"2020/09/16/VS2017+OpenCV3.4实现人脸识别/","link":"","permalink":"http://xaviermin.github.io/2020/09/16/VS2017+OpenCV3.4%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/","excerpt":"调用OpenCV 训练好的分类器和自带的检测函数检测人脸人眼等，步骤简单直接：1.加载分类器。分类器的位置是在\\opencv\\sources\\data\\haarcascades（harr分类器，也有其他的可以用，也可以自己训练）,也可以将分类器事先要放在工程目录中去。 2.调用detectMultiScale()函数检测，调整函数的参数可以使检测结果更加精确。 3.把检测到的人脸等用矩形或圆形等其他图形标出来。","text":"调用OpenCV 训练好的分类器和自带的检测函数检测人脸人眼等，步骤简单直接：1.加载分类器。分类器的位置是在\\opencv\\sources\\data\\haarcascades（harr分类器，也有其他的可以用，也可以自己训练）,也可以将分类器事先要放在工程目录中去。 2.调用detectMultiScale()函数检测，调整函数的参数可以使检测结果更加精确。 3.把检测到的人脸等用矩形或圆形等其他图形标出来。 1. 分类器介绍Haar特征分类器就是一个XML文件，该文件中会描述人体各个部位的Haar特征值。包括人脸、眼睛、嘴唇等等。 Haar特征分类器存放目录：OpenCV安装目录中的\\data\\ haarcascades目录下，opencv3.4.1版本下的Haar特征分类器如下： 根据文件命名可知各个分类器的用途。其中：haarcascade_frontalface_alt.xml与haarcascade_frontalface_alt2.xml都是人脸识别的Haar特征分类器。在编程过程中，可直接取分类器文件的绝对路径，即存放OpenCV包的文件地址，以免运行出错，找不到.xml文件。 2. detectMultiScale函数详解cvHaarDetectObjects()是opencv1中的函数，opencv2中人脸检测使用的是detectMultiScale()函数。它可以检测出图片中所有的人脸，并将人脸用vector保存各个人脸的坐标、大小（用矩形表示），函数由分类器对象调用： 123456789void detectMultiScale( const Mat&amp; image, CV_OUT vector&lt;Rect&gt;&amp; objects, double scaleFactor = 1.1, int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size()); 参数1：image–待检测图片，一般为灰度图像加快检测速度； 参数2：objects–被检测物体的矩形框向量组； 参数3：scaleFactor–表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%; 参数4：minNeighbors–表示构成检测目标的相邻矩形的最小个数(默认为3个)。如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，这种设定值一般用在用户自定义对检测结果的组合程序上； 参数5：flags–要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING，如果设置为CV_HAAR_DO_CANNY_PRUNING，那么函数将会使用Canny边缘检测来排除边缘过多或过少的区域，因此这些区域通常不会是人脸所在区域； 参数6、7：minSize和maxSize用来限制得到的目标区域的范围。 3. 对电脑上的人脸图片进行检测被识别的人像图片需要放到工程目录下，且是.jpg格式。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;using namespace cv;int main(){ // 【1】加载分类器 CascadeClassifier cascade; cascade.load(\"G:\\\\OpenCV\\\\opencv\\\\sources\\\\data\\\\haarcascades\\\\haarcascade_frontalface_alt2.xml\"); Mat srcImage, grayImage, dstImage; // 【2】读取图片 srcImage = imread(\"2.jpg\"); dstImage = srcImage.clone(); imshow(\"【原图】\", srcImage); grayImage.create(srcImage.size(), srcImage.type()); cvtColor(srcImage, grayImage, CV_BGR2GRAY); // 生成灰度图，提高检测效率 // 定义7种颜色，用于标记人脸 Scalar colors[] = { // 红橙黄绿青蓝紫 CV_RGB(255, 0, 0), CV_RGB(255, 97, 0), CV_RGB(255, 255, 0), CV_RGB(0, 255, 0), CV_RGB(0, 255, 255), CV_RGB(0, 0, 255), CV_RGB(160, 32, 240) }; // 【3】检测 vector&lt;Rect&gt; rect; cascade.detectMultiScale(grayImage, rect, 1.1, 3, 0); // 分类器对象调用 printf(\"检测到人脸个数：%d\\n\", rect.size()); // 【4】标记--在脸部画圆 for (int i = 0; i &lt; rect.size(); i++) { Point center; int radius; center.x = cvRound((rect[i].x + rect[i].width * 0.5)); center.y = cvRound((rect[i].y + rect[i].height * 0.5)); radius = cvRound((rect[i].width + rect[i].height) * 0.25); circle(dstImage, center, radius, colors[i % 7], 2); } // 【5】显示 imshow(\"【人脸识别detectMultiScale】\", dstImage); waitKey(0); return 0;} 效果如下： 4. 对摄像头图像的人脸进行检测电脑外接一个USB摄像头，程序运行后自动读取摄像头拍摄的实时图像，对图像中的人脸进行检测。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;opencv2/opencv.hpp&gt;#include&lt;opencv2/core/core.hpp&gt; // 核心组件#include&lt;opencv2/objdetect/objdetect.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; // GUI#include&lt;opencv2/imgproc/imgproc.hpp&gt; // 图像处理using namespace cv;using namespace std;CascadeClassifier cascade;//训练文件路径//Note：路径需要用双右下划线，即\"\\\\\"string xmlPath = \"G:\\\\OpenCV\\\\opencv\\\\sources\\\\data\\\\haarcascades\\\\haarcascade_frontalface_alt2.xml\";int main(){ //【1】加载分类器 cascade.load(xmlPath); if (!cascade.load(xmlPath)) //加载训练文件 { cout &lt;&lt; \"不能加载指定的xml文件\" &lt;&lt; endl; return -1; } // 【2】打开摄像头 VideoCapture capture; capture.open(0);//打开摄像头 注意这个地方的参数 if (!capture.isOpened()) { cout &lt;&lt; \"open camera failed.\" &lt;&lt; endl; return -1; } // 定义7种颜色，用于标记人脸 Scalar colors[] = { // 红橙黄绿青蓝紫 CV_RGB(255, 0, 0), CV_RGB(255, 97, 0), CV_RGB(255, 255, 0), CV_RGB(0, 255, 0), CV_RGB(0, 255, 255), CV_RGB(0, 0, 255), CV_RGB(160, 32, 240) }; Mat srcImage, grayImage; while (1) { // 【3】处理图像 capture &gt;&gt; srcImage;//读取图像至srcImage if (srcImage.empty()) { continue; } if (srcImage.channels() == 3) { cvtColor(srcImage, grayImage, CV_RGB2GRAY); // 生成灰度图，提高检测效率 } else { grayImage = srcImage; } // 【4】检测 vector&lt;Rect&gt; faces; cascade.detectMultiScale(grayImage, faces, 1.1, 3, 0, Size(0, 0)); //检测人脸 if (faces.size() &gt; 0) { printf(\"检测到人脸个数：%d\\n\", faces.size()); // 【5】标记--在脸部画圆 for (int i = 0; i &lt; faces.size(); i++) { Point center; int radius; center.x = cvRound((faces[i].x + faces[i].width * 0.5)); center.y = cvRound((faces[i].y + faces[i].height * 0.5)); radius = cvRound((faces[i].width + faces[i].height) * 0.25); circle(srcImage, center, radius, colors[i % 7], 2); } } imshow(\"CamerFace\", srcImage); // 显示 if (waitKey(1) &gt; 0) // delay ms 等待按键退出 { break; } } return 0;} 效果如下：","categories":[],"tags":[]},{"title":"VS2017中部署OpenCV3.4.1","slug":"VS2017中部署OpenCV3.4.1","date":"2020-09-16T04:58:11.988Z","updated":"2020-09-16T04:57:19.552Z","comments":true,"path":"2020/09/16/VS2017中部署OpenCV3.4.1/","link":"","permalink":"http://xaviermin.github.io/2020/09/16/VS2017%E4%B8%AD%E9%83%A8%E7%BD%B2OpenCV3.4.1/","excerpt":"OpenCV简介OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的IPP进行加速处理。OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。简单理解OpenCV就是一个库，是一个SDK，一个开发包，解压后直接用就可以。","text":"OpenCV简介OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的IPP进行加速处理。OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。简单理解OpenCV就是一个库，是一个SDK，一个开发包，解压后直接用就可以。 1. 安装VS2017前面说了，OpenCV是一个SDK，得使用工具开发它，比如Visual Studio，网站教程比较多的是VS2017中部署OpenCV。 VS2017的安装此处省略，可以去官网下载，也可以网上搜安装包，推荐微信公众号：软件安装管家。 2. 下载并配置OpenCV2.1 下载在OpenCV官网下载你需要的版本，点击RELEASES（发布）。 下载后是个.exe文件，不像一般软件双击.exe文件进行安装，这个是双击进行解压（点击Extract），也可以理解为安装，实质就是解压一下，完了是个文件夹，放到你想放置的位置，打开文件夹是这样 其中build是OpenCV使用时要用到的一些库文件，而sources中则是OpenCV官方提供的一些demo示例源码。 2.2 配置把OpenCV文件夹放好地方后，依次选择计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量，找到Path变量，选中并点击编辑，然后新建把你的OpenCV执行文件的路径填进去，然后一路点确定，这样环境变量就配置完了。 3. VS2017中部署OpenCV打开VS2017，新建一个空项目。 右击源文件-&gt;添加-&gt;新建项 选择一个C++文件，点击添加 找到属性管理器，双击Debug|x64下的Microsoft.Cpp.x64.user，进行配置 对属性中的 VC++目录-&gt;包含目录和VC++目录-&gt;库目录进行添加相关路径，根据自己存放OpenCV的路径添加 包含目录中加入 G:\\OpenCV\\opencv\\build\\include G:\\OpenCV\\opencv\\build\\include\\opencv G:\\OpenCV\\opencv\\build\\include\\opencv2 库目录中加入 G:\\OpenCV\\opencv\\build\\x64\\vc15\\lib 在链接器-&gt;输入-&gt;附加依赖项中加入opencv_world341d.lib 再接着，在链接器-&gt;常规-&gt;附加库目录添加G:\\OpenCV\\opencv\\build\\x64\\vc15\\lib 最后解决方案平台一栏换成X64 下面进行测试，在刚才新建的工程文件目录下，添加一张.jpg格式的图片 回到工程添加的C++文件中，输入代码 12345678#include&lt;opencv2/opencv.hpp&gt;using namespace cv;int main(){ Mat img = imread(\"1.jpg\"); //读入一张图片 imshow(\"显示图片成功\", img); //在窗口中显示图片 waitKey(30000); //等待30000ms(30s)后窗口自动关闭 } 点击本地调试 图片显示成功，运行30s自动退出。 以上，配置完成！","categories":[],"tags":[]},{"title":"ESP8266连接阿里云","slug":"ESP8266连接阿里云","date":"2020-09-09T08:02:55.506Z","updated":"2020-09-09T08:17:38.562Z","comments":true,"path":"2020/09/09/ESP8266连接阿里云/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/ESP8266%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91/","excerpt":"基于Arduino平台用ESP8266接入阿里云前面在零基础快速学习Android开发的两篇博客里介绍了基于EMQ搭建自己的MQTT服务器，是免费使用的，而想使用阿里云的MQTT服务器应该是要购买阿里云的云服务，才能使用阿里云物联网管理平台，目前因为是学生，加上今年上半年疫情原因，阿里云针对学生开放免费半年的使用期限，可能我知道的比较晚，申请完只有两个月免费使用，但了解了解阿里云也足够了，具体操作可以搜B站视频，阿里云白嫖一年免费服务器？学生党专属福利！阿里云在家实践活动。","text":"基于Arduino平台用ESP8266接入阿里云前面在零基础快速学习Android开发的两篇博客里介绍了基于EMQ搭建自己的MQTT服务器，是免费使用的，而想使用阿里云的MQTT服务器应该是要购买阿里云的云服务，才能使用阿里云物联网管理平台，目前因为是学生，加上今年上半年疫情原因，阿里云针对学生开放免费半年的使用期限，可能我知道的比较晚，申请完只有两个月免费使用，但了解了解阿里云也足够了，具体操作可以搜B站视频，阿里云白嫖一年免费服务器？学生党专属福利！阿里云在家实践活动。 1.ESP8266 Arduino开发环境的搭建1.1 下载Arduino官网链接：Download the Arduino IDE 1.2 安装Arduino安装步骤参考百度，教程一搜一大把… 1.3 配置ESP8266环境在Arduino中针对ESP8266的基本配置这里不多做介绍，主要介绍ESP8266接入阿里云需要哪些东西。 1.3.1 安装PubSubClient库打开工具-&gt;管理库，搜索PubSubClient，安装最新版本即可。 1.3.2 安装ArduinoJson库打开工具-&gt;管理库，搜索ArduinoJson，安装 5 版本，选择任意一个均可。 1.3.3 安装Crypto库打开工具-&gt;管理库，搜索Crypto，安装最新版本即可。这是个加密函数库，里面包含了SHA256.h，是加密功能的头文件。 2.阿里云物联网平台的配置进入阿里云物联网平台官网，点击控制台-&gt;物联网管理平台。 点击设备管理-&gt;产品-&gt;创建产品，创建一个控制ESP8266开发板上LED灯的产品。 点击设备管理-&gt;设备-&gt;添加设备，设备所属产品选择上一步创建的产品，给设备取合适的名字和备注，添加完成后在设备列表中显示有刚才添加的设备，但状态/启用状态为未激活状态。 下面进行ESP8266程序的配置。 3.ESP8266程序配置3.1 修改WIFI名称和密码将程序中WIFI_SSID、WIFI_PASSWD的宏定义改成自己的WIFI。 12#define WIFI_SSID \"TP-LINK_531\"#define WIFI_PASSWD \"zhoulianying531\" 3.2 修改设备信息将程序中PRODUCT_KEY、DEVICE_NAME、DEVICE_SECRET的宏定义改成想要链接的设备信息，这里改成上述步骤创建的设备信息。 123#define PRODUCT_KEY \"a1qBJBdexnM\" //替换自己的PRODUCT_KEY#define DEVICE_NAME \"LED_control\" //替换自己的DEVICE_NAME#define DEVICE_SECRET \"b3a3fa8711aa2cd1e7ea21f34336e55d\"//替换自己的DEVICE_SECRET 点击设备后面的操作-&gt;查看，即可看到需要的设备信息。 至此，需要配置的地方全部完成。 上述信息修改完成后，上传到ESP8266开发板上，打开Arduino的串口监视器，即可看到ESP82666上传到阿里云的信息。 回到阿里云物联网平台，即可看到刚创建的设备状态显示为在线。 点击监控运维-&gt;在线调试可对设备进行远程控制，此处可以控制ESP8266上面LED灯的亮灭。 设备正常运行，阿里云连接成功！！！","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（十一）","slug":"RISC-V on T-Core系列课程（十一）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-15T06:26:29.773Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（十一）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/","excerpt":"第十一讲——RISC-V实战演练之自定义指令本讲介绍了自定义指令的软件实现流程，包含指令操作码的定义生成、GNU toochain的修改验证、C代码内联汇编方式调用自定义指令等。该讲还详细阐述了RISC-V on T-Core自定义指令实现流程的每一个步骤，并设计有一个矩阵乘法的demo，以实现和验证dot自定义指令对运算时间、周期和指令数、CPI值等的提升。","text":"第十一讲——RISC-V实战演练之自定义指令本讲介绍了自定义指令的软件实现流程，包含指令操作码的定义生成、GNU toochain的修改验证、C代码内联汇编方式调用自定义指令等。该讲还详细阐述了RISC-V on T-Core自定义指令实现流程的每一个步骤，并设计有一个矩阵乘法的demo，以实现和验证dot自定义指令对运算时间、周期和指令数、CPI值等的提升。 1. RISC-V on T-Core的框架整体框架","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（十）","slug":"RISC-V on T-Core系列课程（十）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-16T01:24:40.013Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（十）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89/","excerpt":"第十讲——RISC-V实战演练之定时器、PWM、I2C、SPI本讲从以下四个方面展开：其一，系统介绍了 RISC-V on T-Core 上的定时器，并详细讲述了如何实现定时的功能；其二，介绍了如何使用 PWM 来进行控制；其三，详细阐述了如何使用 I2C 控制器对 SIF-TMD 子卡上的 I2C 设备实现读写操作。最后，还介绍了如何使用 SPI 控制器与 SIF-TMD 上的 SPI 设备进行通信。","text":"第十讲——RISC-V实战演练之定时器、PWM、I2C、SPI本讲从以下四个方面展开：其一，系统介绍了 RISC-V on T-Core 上的定时器，并详细讲述了如何实现定时的功能；其二，介绍了如何使用 PWM 来进行控制；其三，详细阐述了如何使用 I2C 控制器对 SIF-TMD 子卡上的 I2C 设备实现读写操作。最后，还介绍了如何使用 SPI 控制器与 SIF-TMD 上的 SPI 设备进行通信。 1. RISC-V on T-Core的框架整体框架","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（八）","slug":"RISC-V on T-Core系列课程（八）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-15T06:09:00.532Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（八）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/","excerpt":"第八讲——RISC-V on T-Core的开发流程本讲从RISC-V on T-Core的框架出发， 系统介绍了RISC-V CPU 在T-Core上的实现及其嵌入式设计的流程。此外，在简单介绍TRRV-E-SDK包后，step by step地搭建RISC-V on T-Core的开发环境，并且对T-Core RISC-V 硬件开发流程和应用程序开发流程进行了鞭辟入里的解析：包括如何运用Quartus Prime工具及eclipse软件来进行实操，以及如何使用makefile文件一键编译、一键下载应用程序到T-Core开发板等。","text":"第八讲——RISC-V on T-Core的开发流程本讲从RISC-V on T-Core的框架出发， 系统介绍了RISC-V CPU 在T-Core上的实现及其嵌入式设计的流程。此外，在简单介绍TRRV-E-SDK包后，step by step地搭建RISC-V on T-Core的开发环境，并且对T-Core RISC-V 硬件开发流程和应用程序开发流程进行了鞭辟入里的解析：包括如何运用Quartus Prime工具及eclipse软件来进行实操，以及如何使用makefile文件一键编译、一键下载应用程序到T-Core开发板等。 1. RISC-V on T-Core的框架整体框架 T-Core开发板下载链路选择 2. TRRV-E-SDK简介TRRV-E-SDK是友晶科技基于开源HBird-E-SDK平台修改的 TRRV-E-SDK基于HBird-E-SDK的主要修改： \\software：基于T-Core开发板外设的软件示例 \\work：基于GitHub的源码重新编译的工具链 添加blaster_6810.hex，用于make upload软件示例 基于T-Core开发板修改Makefile 3. RISC-V on T-Core开发环境的搭建开发环境 Linux环境下USB Blaster II驱动的安装 切换到/etc/udev/rules.d文件夹路径，使用touch命令创建51-usbblaster.rules文件 使用gedit命令打开51-usbblaster.rules文件，添加以下内容后保存： 12SUBSYSTEMS==\"usb\",ATTRS{idVendor}==\"09fb\",ATTRS{idProduct}==\"6010\",MODE=\"0666\"SUBSYSTEMS==\"usb\",ATTRS{idVendor}==\"09fb\",ATTRS{idProduct}==\"6810\",MODE=\"0666\" 下载好的E203开发包在Linux环境下解压缩 OpenJDK安装 OpenOCD安装 4. T-Core RISC-V硬件开发流程视频教程是基于Linux Quartus开发 创建TRRV Core工程 创建顶层.v文件 例化2个PLL 添加蜂鸟core源文件 管脚分配 编译生成.pof配置文件 烧写.pof文件到FPGA板子上（使用命令行烧写.pof文件） 5. T-Core RISC-V应用程序开发流程 启动Eclipse创建blinking_LED1工程 设置blinking_LED1工程工程BSP 设置工具链 设置编译和链接选项 设置工程的包含路径和文件 编译并运行blinking_LED1工程 调试blinking_LED1工程 RISC-V工具链 Makefile详解 编译应用程序 下载二进制文件","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（十二）","slug":"RISC-V on T-Core系列课程（十二）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-15T06:27:39.356Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（十二）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/","excerpt":"第十二讲——RISC-V实战演练之FreeRTOS在这一讲中，首先介绍了常见的操作系统及 FreeRTOS 系统特性；然后，着重介绍了FreeRTOS 的工作原理，包括任务管理，内存管理，任务间通信的队列，信号量，互斥量，以及中断管理，软件定时器，临界区和挂起调度器等；最后，通过一个实例，介绍了将 FreeRTOS 移植到 RISC-V 的关键内容和创建 FreeRTOS 工程中进行工程配置的注意事项，并通过具体代码对 FreeRTOS 实时任务调度原理进行了讲解。","text":"第十二讲——RISC-V实战演练之FreeRTOS在这一讲中，首先介绍了常见的操作系统及 FreeRTOS 系统特性；然后，着重介绍了FreeRTOS 的工作原理，包括任务管理，内存管理，任务间通信的队列，信号量，互斥量，以及中断管理，软件定时器，临界区和挂起调度器等；最后，通过一个实例，介绍了将 FreeRTOS 移植到 RISC-V 的关键内容和创建 FreeRTOS 工程中进行工程配置的注意事项，并通过具体代码对 FreeRTOS 实时任务调度原理进行了讲解。 1. RISC-V on T-Core的框架整体框架","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（九）","slug":"RISC-V on T-Core系列课程（九）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-16T01:23:37.627Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（九）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89/","excerpt":"第九讲——RISC-V实战演练之GPIO与UART本讲将从以下三个方面展开：其一，将系统介绍 RISC-V on T-Core 的 GPIO 特性，以及如何实现GPIO读写控制；其二，将对软件上如何对中断进行仲裁及处理的机制进行深入讲解；其三，将详细阐述包含printf函数的移植实现在内的UART通讯。","text":"第九讲——RISC-V实战演练之GPIO与UART本讲将从以下三个方面展开：其一，将系统介绍 RISC-V on T-Core 的 GPIO 特性，以及如何实现GPIO读写控制；其二，将对软件上如何对中断进行仲裁及处理的机制进行深入讲解；其三，将详细阐述包含printf函数的移植实现在内的UART通讯。 1. 实战之GPIO读写E203外设概览 外设地址分配 实验一：GPIO读写 GPIO读写流程 2. 实战之GPIO中断外部中断 GPIO外部中断 外部中断设置步骤 中断处理机制 中断相关寄存器 实验二：GPIO中断 程序流程图 3. 实战之串口UARTUART串口控制器 UART寄存器定义 UART波特率配置 实验三：串口通讯 UART收发实现流程","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（七）","slug":"RISC-V on T-Core系列课程（七）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:12:02.367Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（七）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"第七讲——RISC-V处理器的可扩展性设计及实现本讲主要介绍 了RISC-V 处理器的可扩展性设计与实现。首先，从指令集出发，分析 了RISC-V 处理器可扩展性的体现；然后，着重介绍了 RISC-V 自定义指令的流程，并详细分析了自定义指令时对 RISC-V 处理器硬件的修改；最后，介绍了如何在 RISC-V on T-Core 上实现一个自定义的 DOT 指令的代码。","text":"第七讲——RISC-V处理器的可扩展性设计及实现本讲主要介绍 了RISC-V 处理器的可扩展性设计与实现。首先，从指令集出发，分析 了RISC-V 处理器可扩展性的体现；然后，着重介绍了 RISC-V 自定义指令的流程，并详细分析了自定义指令时对 RISC-V 处理器硬件的修改；最后，介绍了如何在 RISC-V on T-Core 上实现一个自定义的 DOT 指令的代码。 1. RISC-V架构的可扩展性 RISC-V指令集的扩展 指令编码空间的扩展 2. RISC-V自定义指令的基本流程RISC自定义指令 组合逻辑型自定义指令 多周期型自定义指令 RISC-V自定义指令流程 3. RISC-V on T-Core自定义指令设计实现自定义指令——dot指令 dot指令格式选择 CPU硬件修改流程","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（三）","slug":"RISC-V on T-Core系列课程（三）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:51.149Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（三）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"第三讲——RISC-V处理器单指令周期设计与实现本讲主要介绍单指令周期 CPU 的设计与实现。根据指令周期的五个执行步骤：取指、译码、执行、访存、写回，分别设计 RISC-V 六种类型指令的数据通路和控制器。此外，还介绍了 T-Core 开发板上实现 RISC-V 处理器的指令周期所涉及到的五个步骤的代码。","text":"第三讲——RISC-V处理器单指令周期设计与实现本讲主要介绍单指令周期 CPU 的设计与实现。根据指令周期的五个执行步骤：取指、译码、执行、访存、写回，分别设计 RISC-V 六种类型指令的数据通路和控制器。此外，还介绍了 T-Core 开发板上实现 RISC-V 处理器的指令周期所涉及到的五个步骤的代码。 1. 单指令周期CPU概述 指令周期：CPU取出并执行一条指令所需的全部时间。指令执行包括五个步骤——取指（Instruction Fetch）、译码（Instruction Decode）、执行（Execute）、访存（Memory Access）、写回（Write Back）。 CPU周期：也称为机器周期，一个机器周期由若干个时钟周期组成。 CPI（Clock Cycle Per Instruction）：执行每条指令所需的时钟周期数的平均值。 单指令周期CPU：全部指令选用一个CPU周期完成的系统。 2. 单指令周期CPU数据通路的设计需要使用的部件 寄存器堆 3. 单指令周期CPU控制器的设计I-Type指令的控制信号 控制信号的产生 把数据通路和控制器组合在一起，就得到了单指令周期CPU 4. RISC-V on T-Core单指令周期代码解析BIU是系统总线 IFU - 取指、简单译码、分支预测 EXU - 译码、派遣、执行、交付、写回 LSU - 访存","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（五）","slug":"RISC-V on T-Core系列课程（五）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:15.827Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（五）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"第五讲——RISC-V处理器存储器层次化结构设计与实现本讲主要介绍了存储器的层次化结构。首先，从局部性原理出发，构建存储器的层次化结构；然后着重分析了Cache 的原理与改进方法、虚拟存储器的管理两大方面，比如 Cache 的三种映射机制、数据的一致性问题、虚拟存储器的两种管理方法以及 TLB 的 Verilog 实现等；最后对 RISC-V on T-Core 的存储器系统的代码进行了讲解。","text":"第五讲——RISC-V处理器存储器层次化结构设计与实现本讲主要介绍了存储器的层次化结构。首先，从局部性原理出发，构建存储器的层次化结构；然后着重分析了Cache 的原理与改进方法、虚拟存储器的管理两大方面，比如 Cache 的三种映射机制、数据的一致性问题、虚拟存储器的两种管理方法以及 TLB 的 Verilog 实现等；最后对 RISC-V on T-Core 的存储器系统的代码进行了讲解。 1. 存储器层次化结构概述计算机的主要三大件：CPU、存储器、IO设备。 速度比较快的存储器靠近处理器，速度比较慢的离处理器比较远。存储器的层次化结构主要由两个层次：缓存和主存、主存和辅存。 缓存和主存：主要解决CPU和主存速度不匹配的问题，缓存速度比主存速度快很多。 主存和辅存：主要解决村相互系统流量的问题。 SRAM和DRAM 2. Cache的原理与改进Cache的结构 详细讲解参考博客：存储层次结构（二） 3. 虚拟存储器管理及TLB设计虚拟存储器 虚拟存储器的管理 分段管理 分页管理 RISC-V存储器相关的指令 4. RISC-V on T-Core的存储器系统代码解析E203 CPU存储器框图 TCM=Tightly Coupled Memory，是一种高速缓存，据说是被直接集成在CPU芯片中。DS有两种TCM，分别是ITCM（Instruction TCM）和DTCM（Data TCM）。 ITCM&amp;DTCM：ITCM是cortex内核中指令传输总线，DTCM是cortex内核中数据传输总线是cpu内核同flash及sram之间传输指令和数据的通道，指令的取指和执行及数据的读写在性能及管理上存在差异性。","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（六）","slug":"RISC-V on T-Core系列课程（六）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:05.303Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（六）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"第六讲——RISC-V处理器中断与异常处理机制及实现本讲主要介绍了CPU中断与异常的概念，包括中断与异常的屏蔽、等待、套嵌和优先级等。此外，还详细介绍了中断与异常相关的寄存器，以及单指令周期数据通路中断与异常的控制机制和流水线中断与异常的控制机制。同样，在最后还对RISC-V on T-Core流水线的中断与异常控制代码进行了解析。","text":"第六讲——RISC-V处理器中断与异常处理机制及实现本讲主要介绍了CPU中断与异常的概念，包括中断与异常的屏蔽、等待、套嵌和优先级等。此外，还详细介绍了中断与异常相关的寄存器，以及单指令周期数据通路中断与异常的控制机制和流水线中断与异常的控制机制。同样，在最后还对RISC-V on T-Core流水线的中断与异常控制代码进行了解析。 1. 中断与异常的处理机制异常（Exception）：内部同步异常，出现在CPU内部，例如存储非法访问，未定义指令，系统调用… 中断（Interrupt）：外部异步中断，来自CPPU内部，例如GPIO，串口，定时器… 中断和异常的处理过程 中断和异常的相关寄存器（CSR） 寄存器具体意义 查询中断 向量中断 中断和异常的退出过程 中断返回 中断屏蔽和中断等待 中断优先级 2. 带中断和异常处理功能的CPU的设计与实现单指令周期CPU中 五级流水线中 3. RISC-V on T-Core的中断与异常代码解析E203二级流水线数据通路","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（四）","slug":"RISC-V on T-Core系列课程（四）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:41.390Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（四）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"第四讲——RISC-V处理器流水线设计及实现本讲系统介绍了处理器流水线的概念与结构，并对流水线与单指令周期进行了比较分析。此外，探讨了流水线设计带来的冒险，诸如结构冒险、数据冒险、控制冒险等，及其解决方法。最后，对RISC-V on T-Core流水线实现的代码进行了解析。博客参考：课程——计算机组成与设计","text":"第四讲——RISC-V处理器流水线设计及实现本讲系统介绍了处理器流水线的概念与结构，并对流水线与单指令周期进行了比较分析。此外，探讨了流水线设计带来的冒险，诸如结构冒险、数据冒险、控制冒险等，及其解决方法。最后，对RISC-V on T-Core流水线实现的代码进行了解析。博客参考：课程——计算机组成与设计 1. 处理器流水线概念与结构在单指令周期CPU中，所有指令的指令周期是等长的，指令周期的长短取决于指令周期最长的一条，以此确保每条指令在一个周期内都能完成，所以在单指令周期CPU中处理器在一个指令周期中经常会处在等待的状态。 提高处理器的性能，采用流水线技术 单指令周期与流水线的比较 处理器性能评估“铁律”：程序执行时间=程序指令数目 x 指令周期数CPI x 时钟周期 单指令周期CPU的CPI是1，流水线CPI约等于1（大于1） 流水线阶段划分 为了确保硬件共享的同时，前面的指令数据不被丢失，需要增加阶段寄存器来保存中间的值可控制信号。这些增加的寄存器称为流水线寄存器。 2. 处理器流水线的冒险与解决流水线技术之所以能提高性能 究其本质是利用了时间上的并行性，那它让原本应该先后执行的指令在时间上一定程度的并行起来，然而这也会带来一些冲突和矛盾，进而可能引发错误。 冒险（Hazard）：在流水线中我们希望当前每个时钟周期都有一条指令进入流水线可以执行。但在某些情况下，下一条指令无法按照预期开始执行，这种情况就被称为冒险。 冒险分为三种： 结构冒险：如果一条指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务，那就导致了结构冒险。（这里结构是指硬件当中的某个部件） 数据冒险：如果一条指令需要某数据而该数据正在被之前的指令操作，那这条指令就无法执行，就导致了数据冒险。 控制冒险：如果现在要执行哪条指令，是由之前指令的运行结果决定，而现在那条之前指令的结果还没产生，就导致了控制冒险。 结构冒险解决方法： 指令之间轮流使用硬件，此时会有一些指令需要被阻塞。 在设计中添加更多的硬件以满足需求。 寄存器文件结构冒险 流水线的数据冒险分类 阻塞（插入气泡）会降低CPU性能，即增大CPI值 流水线的控制冒险 3. RISC-V on T-Core流水线代码解析E203流水线数据通路","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（二）","slug":"RISC-V on T-Core系列课程（二）","date":"2020-09-09T07:51:55.782Z","updated":"2020-09-14T03:09:03.155Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（二）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"第二讲——RISC-V处理器ALU设计与实现本讲主要介绍了数据通路部件中的核心——ALU（Arithmetic and Logic Unit，算术逻辑运算单元）。从 RISC-V 指令集出发，着重分析 RISC-V 六种类型的指令。接着，从1位 ALU 的设计实现开始，由易到难，演示通过逐步添加运算单元，并将其进行扩展等操作，使之最后形成一个功能完善的、32位 RISC-V ALU。最后，将介绍在T-Core 开发板上实现 RISC-V ALU 所需的 Verilog HDL 代码，结合 ALU 设计实现的理论知识，从 ALU 的整体框架入手，逐一分析每个模块所涉及的控制信号和运算。","text":"第二讲——RISC-V处理器ALU设计与实现本讲主要介绍了数据通路部件中的核心——ALU（Arithmetic and Logic Unit，算术逻辑运算单元）。从 RISC-V 指令集出发，着重分析 RISC-V 六种类型的指令。接着，从1位 ALU 的设计实现开始，由易到难，演示通过逐步添加运算单元，并将其进行扩展等操作，使之最后形成一个功能完善的、32位 RISC-V ALU。最后，将介绍在T-Core 开发板上实现 RISC-V ALU 所需的 Verilog HDL 代码，结合 ALU 设计实现的理论知识，从 ALU 的整体框架入手，逐一分析每个模块所涉及的控制信号和运算。 1. ALU概述ALU是什么 数据通路 2. RISC-V指令集和ALU的联系RISC-V指令集类型（六种） R-type指令与ALU I-type指令与ALU Load/Store指令与ALU B-type指令与ALU Jump指令与ALU U-type指令与ALU 总结：RISC-V指令涉及到的运算： R-type/I-type：加法、减法、与、或、异或、比较大小、逻辑移位、算术移位 B-type：比较相等、比较大小 U-type：左移、加法 S-type：加法 J-type：加法 RISC-V ALU基本功能： 算术运算：加法、减法 逻辑运算：与、或、异或 其他运算：移位、比较 将多种算术和逻辑组合到一个单元内 3. RISC-V ALU的设计与实现ALU的设计：1位扩展到32位 1位ALU的实现 32位ALU的实现 ALU减法运算实现 ALU比较运算实现 RISC-V乘法器实现 RISC-V除法器实现 4. RISC-V on T-Core ALU代码解析ALU的子模块的运算请求","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（一）","slug":"RISC-V on T-Core系列课程（一）","date":"2020-09-09T07:17:04.044Z","updated":"2020-09-14T03:09:21.865Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（一）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"第一讲——RISC-V架构处理器基础RISC-V（发音为“risk-five”）是一个基于精简指令集（RISC）原则的开源指令集架构（ISA）。与大多数指令集相比，RISC-V指令集可以自由地用于任何目的，允许任何人设计、制造和销售RISC-V芯片和软件。虽然这不是第一个开源指令集，但它具有重要意义，因为其设计使其适用于现代计算设备（如仓库规模云计算机、高端移动电话和微小嵌入式系统）。设计者考虑到了这些用途中的性能与功率效率。该指令集还具有众多支持的软件，这解决了新指令集通常的弱点。","text":"第一讲——RISC-V架构处理器基础RISC-V（发音为“risk-five”）是一个基于精简指令集（RISC）原则的开源指令集架构（ISA）。与大多数指令集相比，RISC-V指令集可以自由地用于任何目的，允许任何人设计、制造和销售RISC-V芯片和软件。虽然这不是第一个开源指令集，但它具有重要意义，因为其设计使其适用于现代计算设备（如仓库规模云计算机、高端移动电话和微小嵌入式系统）。设计者考虑到了这些用途中的性能与功率效率。该指令集还具有众多支持的软件，这解决了新指令集通常的弱点。 1. 计算机体系结构整体结构图 处理器关键技术 存储器结构与内存访问 2. 指令集架构（ISA）知乎上一篇通俗易懂的讲解科普ISA、CPU架构原理。 ISA位于软件和硬件之间的接口，一套标准的规范，不具备实体，以文档的形式发布。 3. RISC-V指令架构RISC-V诞生于2010年，有如下特点： 指令集完全开源免费（规范） 指令书目简洁 模块化的指令集 可扩展定制指令 完整工具链 有大量的开源实现和流片案例 RISC-V模块化的指令集 RISC-V统一的指令编码 RISC-V R（Register）型指令 RISC-V I（Immediate）型指令 RISC-V S（Store）型B（Branch）型指令，B是S的变体 RISC-V U（Upper immediate）型 J（ Jump）型指令，J是U的变体 RISC-V通用寄存器组 CSR（控制状态）寄存器组：用于记录运行状态，处理器内部寄存器 RISC-V的存储访问 RISC-V的寻址方式 RISC-V的中断 RISC-V的中断处理机制：响应中断和退出中断。 RISC-V支持机器模式、监督模式、用户模式 4. RISC-V on T-CoreT-Core开发板简介 RISC-V在Intel FPGA上实现 蜂鸟E203 MCU SoC RISC-V on T-Core的开发流程 总结介绍计算机系统的结构和处理器关键技术，结合ISA的定义对RISC-V指令集架构的讲解，包括RISC-V指令集的编码、寄存器组、存储访问、寻址访问、中断处理机制，简要 介绍RISC-V在T-Core上的实现。","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（五）","slug":"零基础快速学习Android开发（五）","date":"2020-09-05T05:10:25.549Z","updated":"2020-09-05T07:09:37.174Z","comments":true,"path":"2020/09/05/零基础快速学习Android开发（五）/","link":"","permalink":"http://xaviermin.github.io/2020/09/05/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"MQTT服务器的搭建——基于EMQ平台（Windows）前面一篇博客介绍了在Linux系统上基于EMQ平台搭建了MQTT服务器，这两天在测试连接过程中遇到问题，主要还是笔记本不行…开虚拟机太太太卡了，索性放弃，重新在台式机Windows系统上搭建MQTT服务器，成功之后发现也挺好用，测试啥的都很方便。下面直接介绍安装和测试过程，对EMQ、MQTT不做介绍。","text":"MQTT服务器的搭建——基于EMQ平台（Windows）前面一篇博客介绍了在Linux系统上基于EMQ平台搭建了MQTT服务器，这两天在测试连接过程中遇到问题，主要还是笔记本不行…开虚拟机太太太卡了，索性放弃，重新在台式机Windows系统上搭建MQTT服务器，成功之后发现也挺好用，测试啥的都很方便。下面直接介绍安装和测试过程，对EMQ、MQTT不做介绍。 EMQ官网：https://www.emqx.io/cn 官方介绍文档：https://docs.emqx.net/broker/v3/cn/install.html 登录官网可下载EMQ X安装包 官方介绍文档里有针对各种系统的安装步骤，但不够详细，只参考这个进行安装可能会出现各种问题，所有有事儿还是得找百度~ 1.在Windows下安装EMQ X Broker1.1 下载EMQ X安装包同样，先下载安装包，上链接 -&gt; EMQ X Broker 打开下载链接后选择版本，例如我选择目前的最新版v4.1.4，选择Windows/Windows/x86_64/zip。 下载完成进行解压，我直接解压到E盘，软件包里即包含如下文件，注意EMQ的存放路径不能有中文和空格。 1.2 安装EMQ X Broker使用管理员身份运行cmd命令窗口，跳转到emqx的存放路径下的/bin文件夹路径。 输入命令emqx install，安装emq。 输入命令emqx start，启动emq，若路径跳转到/emqx文件夹下，表明启动成功，若后续继续使用命令行输入，还需要跳转到/bin目录下。 然后可以使用命令emqx_ctl status查看emqx的状态。 如果要停止 EMQ X Broker，使用如下命令emqx stop，提示ok即停止。 1.3 验证完成以上步骤，EMQ应该已经成功启动，下面进行验证。 打开浏览器，输入http://localhost:18083 来查看 Dashboard，默认用户名是 admin，密码是 public。 能进入控制台，即表示EMQ安装成功！ 2.数据交互测试2.1 利用MQTTBox进行测试MQTTBox测试工具下载链接：http://workswithweb.com/mqttbox.html 使用MQTTBox工具测试MQTT服务器能否正常通信，自定义发布主题和订阅主题，安装完成后打开，点击主页的Creat MQTT Client创建一个MQTT客户端，信息填写如下图所示。 保存之后自动显示Connected，即连接成功，到控制台刷新可以看到刚创建的MQTT客户端信息。 MQTTBox连接上MQTT服务器后，进行订阅和发布主题。 2.2 控制台Websocket连接注意主机地址和端口需填写正确，主机地址为127.0.0.1，Websocket做MQTT连接时端口应该为8083。 2.3 订阅和发布消息测试连接成功后，订阅主题和发布消息进行测试，Websocket和MQTTBox一个发一个收，两两可以互相发送和接收消息，之前MQTTBox发布的主题为publish，订阅的主题为subscribe，所以Websocket这里就应该订阅MQTTBox发布的主题publish，向subscribe主题发送消息（即subscribe相当于Websocket的发布主题），设置如下： 在MQTTBox上发布一条消息hello world，然后在控制台的订阅消息列表可以看到刚才从MQTTBox发布的消息。 从Websocket发送一条消息How are you，然后再MQTTBox工具的订阅列表中可以看到。 MQTT服务器能正常发布、订阅消息，即在Windows上搭建成功！！！","categories":[],"tags":[]},{"title":"解决VMware打开报错的问题","slug":"解决VMware打开报错的问题","date":"2020-08-26T16:45:30.269Z","updated":"2020-08-26T17:19:38.837Z","comments":true,"path":"2020/08/27/解决VMware打开报错的问题/","link":"","permalink":"http://xaviermin.github.io/2020/08/27/%E8%A7%A3%E5%86%B3VMware%E6%89%93%E5%BC%80%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"VMware提示以独占方式锁定此配置文件失败。另一个正在运行的VMware进程可能正在使用配置文件前两天使用了VMware虚拟机，正常关闭后，今天再次打开虚拟机的时候提示异常“以独占方式锁定此配置文件失败”，查阅网上的说法，是之前虚拟机未被正常关机，有进程仍然在后台运行占用了配置文件，导致再次开启机器时提示异常。 下面是我在网上找的解决办法，亲测有用！！！","text":"VMware提示以独占方式锁定此配置文件失败。另一个正在运行的VMware进程可能正在使用配置文件前两天使用了VMware虚拟机，正常关闭后，今天再次打开虚拟机的时候提示异常“以独占方式锁定此配置文件失败”，查阅网上的说法，是之前虚拟机未被正常关机，有进程仍然在后台运行占用了配置文件，导致再次开启机器时提示异常。 下面是我在网上找的解决办法，亲测有用！！！ 通过禁用启动项的方式结束旧的进程占用 按“win +R”组合键，进入“运行”，输入msconfig，按回车键。 进入“系统配置”，选中“服务”，勾选左下角“隐藏所有Microsoft服务”，再打开“全部禁止”，打开“应用”。 再打开“服务”边上的“启动”选项，打开“点击任务管理器”。 在列出的启动项上，找到VMware Tray Process点击右键，选中“禁止”，禁止全部启动项。 关闭“任务管理器”，返回“系统配置”界面下打开“确定”，依据提示重启电脑。 电脑重启之后，再次按照上面流程启动所有服务和VMware Tray Process，VMware就可以正常启动了。","categories":[],"tags":[]},{"title":"ESP8266+BME280构建无线气象站","slug":"ESP8266+BME280构建无线气象站","date":"2020-08-25T07:04:31.567Z","updated":"2020-08-25T17:35:28.909Z","comments":true,"path":"2020/08/25/ESP8266+BME280构建无线气象站/","link":"","permalink":"http://xaviermin.github.io/2020/08/25/ESP8266+BME280%E6%9E%84%E5%BB%BA%E6%97%A0%E7%BA%BF%E6%B0%94%E8%B1%A1%E7%AB%99/","excerpt":"简介本案例是做一个简单的气象站，进行温度、湿度、压力、高度的测量。气压传感器模块有GY-68 BMP180 可以测大气压和温度，升级版是GY-BMP280，还有高配版BME280，可以多测一个湿度。 本案例展示了如何将BME280传感器模块与ESP8266一起使用，以使用Arduino IDE读取压力、温度、湿度、压力和估计高度。BME280传感器使用I2C或SPI通信协议与微控制器交换数据。","text":"简介本案例是做一个简单的气象站，进行温度、湿度、压力、高度的测量。气压传感器模块有GY-68 BMP180 可以测大气压和温度，升级版是GY-BMP280，还有高配版BME280，可以多测一个湿度。 本案例展示了如何将BME280传感器模块与ESP8266一起使用，以使用Arduino IDE读取压力、温度、湿度、压力和估计高度。BME280传感器使用I2C或SPI通信协议与微控制器交换数据。 1. 介绍1.1 BME280传感器BME280传感器使用I2C或SPI通信协议进行通信，我使用的是I2C通信协议进行通信，接线非常简单，使用默认的ESP8266 I2C引脚，如下表所示： BME280 ESP8266 VCC 3.3V GND GND SCL GPIO5 (D1) SDA GPIO4 (D2) 1.2 所需硬件 ESP8266开发板 x 1 BME280传感器模块 x 1 杜邦线 x 4 1.3 硬件接线图ESP8266与BME280传感器模块使用I2C通信。为此，将传感器连接到ESP8266 SDA 和 SCL 引脚，如下图所示。 2. 安装库文件该案例的ESP8266固件是使用Arduino IDE开发的。要从BME280传感器模块获取读数，需要安装Adafruit_BME280库。打开Arduino IDE并转到 工具 &gt;管理库，在搜索框中搜索adafruit bme280并安装该库。 还需要安装Adafruit_Sensor库。打开Arduino IDE并转到 工具 &gt;管理库，在搜索框中搜索Adafruit Unified Sensor并安装该库。 安装完成后，重新启动Arduino IDE。 3. 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;Wire.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;Adafruit_Sensor.h&gt;#include &lt;Adafruit_BME280.h&gt;#include \"SSD1306.h\"#define SEALEVELPRESSURE_HPA (1013.25)Adafruit_BME280 bme; // I2CSSD1306 display(0x3c, D2, D1);// Replace with your network details//const char* ssid = \"Xiaomi_wifi\";//const char* password = \"18712183610\";const char* ssid = \"TP-LINK\";const char* password = \"20070529\";float h, t, p, pin;char temperatureFString[6];char humidityString[6];char pressureString[7];char pressureInchString[6];int count=0;// Web Server on port 80WiFiServer server(80);// only runs once on bootvoid setup() { // Initializing serial port for debugging purposes Serial.begin(115200); delay(10); Wire.begin(D2, D1); Wire.setClock(100000); // Connecting to WiFi network Serial.println(); Serial.print(\"Connecting to \"); Serial.println(ssid); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(\".\"); } Serial.println(\"\"); Serial.println(\"WiFi connected\"); // Starting the web server server.begin(); Serial.println(\"Web server running. Waiting for the ESP IP...\"); delay(10000); // Printing the ESP IP address Serial.println(WiFi.localIP()); Serial.println(F(\"BME280 test\")); bool status; status = bme.begin(0x76); if (!status) {// if (!bme.begin()) { Serial.println(\"Could not find a valid BME280 sensor, check wiring!\"); while (1); } // Initialising the UI will init the display too. display.init(); display.flipScreenVertically(); display.setFont(ArialMT_Plain_16);}void getWeather() { h = bme.readHumidity(); t = bme.readTemperature(); //t = t*1.8+32; p = bme.readPressure()/100.0F; pin = 0.02953*p; dtostrf(t, 5, 1, temperatureFString); dtostrf(h, 5, 1, humidityString); dtostrf(p, 6, 1, pressureString); dtostrf(pin, 5, 2, pressureInchString); delay(100);}// runs over and over againvoid loop() { // Listenning for new clients WiFiClient client = server.available(); if (client) { Serial.println(\"New client\"); // bolean to locate when the http request ends boolean blank_line = true; while (client.connected()) { if (client.available()) { char c = client.read(); if (c == '\\n' &amp;&amp; blank_line) { getWeather(); client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); client.println(); // your actual web page that displays temperature client.println(\"&lt;!DOCTYPE HTML&gt;\"); client.println(\"&lt;html&gt;\"); client.println(\"&lt;head&gt;&lt;META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"15\\\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;ESP8266 Weather Webserver&lt;/h1&gt;&lt;h3&gt;Temperature = \"); client.println(temperatureFString); //client.println(\"&amp;deg;F&lt;/h3&gt;&lt;h3&gt;Humidity = \"); client.println(\"&amp;deg;C&lt;/h3&gt;&lt;h3&gt;Humidity = \"); client.println(humidityString); client.println(\"%&lt;/h3&gt;&lt;h3&gt;Pressure = \"); client.println(pressureString); client.println(\"hPa (\"); client.println(pressureInchString); client.println(\"Inch)&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;\"); break; } if (c == '\\n') { // when starts reading a new line blank_line = true; } else if (c != '\\r') { // when finds a character on the current line blank_line = false; } } } // closing the client connection delay(1); client.stop(); Serial.println(\"Client disconnected.\"); } if(count == 0){ getWeather(); display.clear(); //display.drawString(10, 6, \"T=\"+String(t)+\"°F\"); display.drawString(10, 6, \"T=\"+String(t)+\"°C\"); display.drawString(10, 23, \"P=\"+String(p)+\"hPa\"); display.drawString(10, 40, \"RH=\"+String(h)+\"%\"); display.drawRect(0, 0, 127, 63); display.drawRect(1, 1, 125, 61); display.drawRect(2, 2, 124, 60); display.display(); Serial.print(\"Temperature = \"); Serial.print(bme.readTemperature()); Serial.println(\" °C\"); Serial.print(\"Pressure = \"); Serial.print(bme.readPressure() / 100.0F); Serial.println(\" hPa\"); Serial.print(\"Approx.Altitude = \"); Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA)); Serial.println(\" m\"); Serial.print(\"Humidity = \"); Serial.print(bme.readHumidity()); Serial.println(\" %\"); Serial.println(); } count = count+1; if (count==10) count=0; delay(500);} 该代码中包含一个非常基本的HTML网页的代码，输出BME280传感器数据。要注意的是，需要在程序中编辑SSID名称和密码以使其与WiFi网络匹配，然后再将其上载到ESP8266开发板上。 4. 显示效果将程序上传到ESP8266开发板后，ESP8266重新启动，会在串行监视器上打印出WiFi网络中为其分配的本地IP地址、温度、压力、估算高度。 为了通过Web服务器访问这些数据，在连接到同一WiFi网络的任何计算机、平板电脑或手机上打开Web浏览器，然后在URL字段中输入ESP8266 IP地址，然后按Enter键。ESP8266收到客户请求后，会提供一个包含BME传感器读数的网页，如下所示。 参考博客： 使用Arduino IDE的ESP8266和BME280（压力，温度，湿度） ESP8266和BME280创建一个本地/远程气象站","categories":[],"tags":[]},{"title":"解决电脑上GitHub网站打不开的问题","slug":"解决电脑上GitHub网站打不开的问题","date":"2020-08-22T18:06:56.436Z","updated":"2020-08-22T18:33:52.293Z","comments":true,"path":"2020/08/23/解决电脑上GitHub网站打不开的问题/","link":"","permalink":"http://xaviermin.github.io/2020/08/23/%E8%A7%A3%E5%86%B3%E7%94%B5%E8%84%91%E4%B8%8AGitHub%E7%BD%91%E7%AB%99%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"原因：本地DNS无法解析导致的。解决办法：修改hosts文件内容解决步骤：win10系统下操作","text":"原因：本地DNS无法解析导致的。解决办法：修改hosts文件内容解决步骤：win10系统下操作 第一步：电脑搜索记事本应用，以管理员身份运行，打开C盘中C:\\Windows\\System32\\drivers\\etc中的hosts文件。 第二步：通过站长工具找出DNS地址，进入站长工具网站的域名解析网址：http://tool.chinaz.com/dns/ ，在A类型的查询中输入github.com，找出最快的IP地址。 第三步：修改host文件中对应的github.com的IP地址。 第四步：保存host文件，即可打开GitHub网站。 网上有很多博客提供了解决这个问题的办法，试过几个，只有这个是适用我的，多尝试，不行就换另一种方法。 参考博客：https://blog.csdn.net/yuxikuo_1/article/details/107302871","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（四）","slug":"零基础快速学习Android开发（四）","date":"2020-08-22T17:55:54.141Z","updated":"2020-09-05T05:14:29.824Z","comments":true,"path":"2020/08/23/零基础快速学习Android开发（四）/","link":"","permalink":"http://xaviermin.github.io/2020/08/23/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"MQTT服务器的搭建——基于EMQ平台（Linux）EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器。Erlang/OTP是出色的软实时 (Soft-Realtime)、低延时 (Low-Latency)、分布式 (Distributed)的语言平台。EMQ X 设计目标是实现高可靠，并支持承载海量物联网终端的MQTT连接，支持在海量物联网设备间低延时消息路由。","text":"MQTT服务器的搭建——基于EMQ平台（Linux）EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器。Erlang/OTP是出色的软实时 (Soft-Realtime)、低延时 (Low-Latency)、分布式 (Distributed)的语言平台。EMQ X 设计目标是实现高可靠，并支持承载海量物联网终端的MQTT连接，支持在海量物联网设备间低延时消息路由。 EMQ X Broker 是基于高并发的 Erlang/OTP 语言平台开发，支持百万级连接和分布式集群架构，发布订阅模式的开源 MQTT 消息服务器。EMQ X Broker 在全球物联网市场广泛应用。无论是产品原型设计、物联网创业公司、还是大规模的商业部署，EMQ X Broker 都支持开源免费使用。 EMQ X 目前支持的操作系统: Centos6 Centos7 OpenSUSE tumbleweed Debian 8 Debian 9 Debian 10 Ubuntu 14.04 Ubuntu 16.04 Ubuntu 18.04 macOS 10.13 macOS 10.14 macOS 10.15 Windows Server 2019 产品部署建议 Linux 服务器，不推荐 Windows 服务器。 这是官方文档的建议，我因为看到这个建议所以选择在Linux系统中来搭建MQTT服务器，这就要求事先在电脑上装好Linux系统，安装模式和在Windows上应该差不多，大多都是命令行操作。 官方文档提供了在公众系统上安装EMQ X Broker的步骤，可供参考。 1.在Linux下安装EMQ X Broker1.1 下载EMQ X安装包话不多说，先上链接 -&gt; EMQ X Broker 打开下载链接后选择版本，例如我选择目前的最新版v4.2-rc.1，因为我使用的Liunx系统是Ubuntu16.04，所以选择Linux/Ubutu16.04/x86_64/zip。 我是直接下载的安装包，然后直接将压缩包复制粘贴到Linux系统中，另一种方法可以复制下载界面的下载链接，进入Linux的Terminal，输入命令进行下载。 1wget https://www.emqx.io/cn/downloads/broker/v4.2-rc.1/emqx-ubuntu16.04-4.2-rc.1-x86_64.zip 1.2 启动EMQ X Broker下载完成后，使用unzip命令解压，如果没有安装unzip，则使用命令sudo apt-get install unzip安装，还有一点需要注意的是，先查看压缩包放置在哪一级目录下，再解压。 1unzip emqx-ubuntu16.04-4.2-rc.1-x86_64.zip 解压需要一点时间，解压完之后，进入解压出来的emqx文件夹，使用命令启动即可。 1sudo ./bin/emqx start 启动成功会提示started successfully!字样。 然后可以使用命令查看emqx的状态。 如果要停止 EMQ X Broker，使用如下命令；如果要卸载 EMQ X Broker，直接删除 EMQ X 目录即可。 1sudo ./bin/emqx stop 1.3 验证进入控制台查看，EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。 打开浏览器，输入http://localhost:18083 来查看 Dashboard，默认用户名是 admin，密码是 public。 到此，MQTT服务器搭建成功！ 注意：在Linux下安装就要打开Linux下的浏览器查看，我在Windows的浏览器搜索半天显示不出来还以为安装过程有问题…… 2.EMQ X Dashboard2.1 简介EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，你可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。 2.2 启用 DashboardEMQ X Dashboard 功能由 emqx-dashboard 插件实现，该插件默认处于启用状态，它将在 EMQ X 启动时自动加载。如果你希望禁用 Dashboard 功能，你可以将 data/loaded_plugins（请参见 插件）中的 {emqx_dashboard, true} 修改为 {emqx_dashboard, false}。 1{emqx_dashboard, true} 2.3 查看 DashboardEMQ X Dashboard 是一个 Web 应用程序，你可以直接通过浏览器来访问它，无需安装任何其他软件。当 EMQ X 成功运行在你的本地计算机上且 EMQ X Dashboard 被默认启用时，你可以访问 http://localhost:18083 来查看你的 Dashboard，默认用户名是 admin，密码是 public。 详细内容见此链接Dashboard。","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（三）","slug":"零基础快速学习Android开发（三）","date":"2020-08-19T09:45:41.711Z","updated":"2020-08-22T17:55:26.227Z","comments":true,"path":"2020/08/19/零基础快速学习Android开发（三）/","link":"","permalink":"http://xaviermin.github.io/2020/08/19/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"Android Studio中导入jar包——导入MQTT jar包JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。JAR 文件非常类似 ZIP 文件——准确的说，它就是 ZIP 文件，所以叫它文件包。JAR（Java ARchive，Java 归档）是一种与平台无关的文件格式，可将多个文件合成一个文件。用户可将多个 Java applet 及其所需组件（.class 文件、图像和声音）绑定到 JAR 文件中，而后作为单个的简单 HTTP（Hypertext Tranfer Protocal，超文本传输协议）事务下载到浏览器中，从而大大提高下载速度。JAR 格式也支持压缩，从而减小了文件的大小，进一步缩短下载时间。","text":"Android Studio中导入jar包——导入MQTT jar包JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。JAR 文件非常类似 ZIP 文件——准确的说，它就是 ZIP 文件，所以叫它文件包。JAR（Java ARchive，Java 归档）是一种与平台无关的文件格式，可将多个文件合成一个文件。用户可将多个 Java applet 及其所需组件（.class 文件、图像和声音）绑定到 JAR 文件中，而后作为单个的简单 HTTP（Hypertext Tranfer Protocal，超文本传输协议）事务下载到浏览器中，从而大大提高下载速度。JAR 格式也支持压缩，从而减小了文件的大小，进一步缩短下载时间。 导入jar包的方法（通用） 首先去下载需要的jar包，MQTT jar包org.eclipse.paho.client.mqttv3-1.2.0.jar。 将jar包复制到Project下的app-&gt;libs目录下（如果不存在libs目录新建一个）。 右击该jar包，选择Add as library，弹出窗口，点击OK。 Build编译完成显示successful即成功导入jar包。","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（二）","slug":"零基础快速学习Android开发（二）","date":"2020-08-17T13:48:04.215Z","updated":"2020-08-22T17:56:27.148Z","comments":true,"path":"2020/08/17/零基础快速学习Android开发（二）/","link":"","permalink":"http://xaviermin.github.io/2020/08/17/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"控件与界面布局根据B站视频建立的一个MQTT工程，以这个为例，新建一个空白工程，API选择API 23:Android 6.0(Marshmaiiow)（避免错误，选择和up主一样）。下面一一介绍常用控件和界面布局的方法，以及控件与界面之间的通讯、事件的发生等等。常用控件：Button（按钮）、TextView（文本框）、EditText（编辑框）、ImageView（图片）、ProgressBar（进度）、AlertDialog与ProgressDialog（弹窗）。","text":"控件与界面布局根据B站视频建立的一个MQTT工程，以这个为例，新建一个空白工程，API选择API 23:Android 6.0(Marshmaiiow)（避免错误，选择和up主一样）。下面一一介绍常用控件和界面布局的方法，以及控件与界面之间的通讯、事件的发生等等。常用控件：Button（按钮）、TextView（文本框）、EditText（编辑框）、ImageView（图片）、ProgressBar（进度）、AlertDialog与ProgressDialog（弹窗）。 1.Button（按钮）默认情况下，系统会将button内的英文自动转换为大写，如果这不是你想要的效果，可以将textAllCaps属性设为false。 123456789&lt;Button android:layout_width=\"wrap_content\" android:text=\"确定\" android:textColor=\"#FFCC00\" android:textSize=\"16dp\" android:id=\"@+id/bt_1\" android:background=\"@color/colorPrimary\" android:layout_height=\"wrap_content\"&gt;&lt;/Button&gt; 第2、8行：设置按钮的大小，可将wrap_content（自适应大小）直接换成大小数值，如100dp； 第3-5行：设置文字及其属性（颜色、大小等）； 第6行：设置控件id，用来和JAVA文件通讯或者说是绑定事件的； 第7行：设置按钮的背景，可以是颜色(配色表)，可以是图标(图标库)图片，网上下载的图标必须是PNG格式，直接复制下载好的图标粘贴到项目的app-&gt;res-&gt;drawable目录下，然后替换参数； 2.TextView（文本框）android中所有控件都有android:layout_width和android:layout_height这两个属性。这两个属性的可选值有3个：match_parent，fill_parent和wrap_parent。其中，match_parent和fill_parent意义相同，官方更推荐使用match_parent。 1234567&lt;TextView android:layout_width=\"wrap_content\" android:textSize=\"30sp\" android:text=\"这是一个文本框\" android:id=\"@+id/text_1\" android:layout_height=\"wrap_content\"&gt;&lt;/TextView&gt; 3.EditText（编辑框）1234567&lt;EditText android:layout_width=\"wrap_content\" android:hint=\"请输入名称\" android:id=\"@+id/edit_1\" android:maxLines=\"2\" android:layout_height=\"wrap_content\"&gt;&lt;/EditText&gt; 第3行：表示输入框中的一段提示性文本； 第5行：表示输入框中可向下拓展的最大行数，超过这个行数则会产生滚动； 4.ImageView（图片）123456&lt;ImageView android:layout_width=\"wrap_content\" android:id=\"@+id/img_1\" android:src=\"@drawable/open\" android:layout_height=\"wrap_content\"&gt;&lt;/ImageView&gt; 第4行：选择图片资源，和图标一样，粘贴到项目app-&gt;res-&gt;drawable目录下的； 以上四个是常用控件，整体效果如下，后面的控件不常用。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center\" tools:layout_editor_absoluteX=\"0dp\" tools:layout_editor_absoluteY=\"0dp\"&gt; &lt;Button android:layout_width=\"50dp\" android:text=\"确定\" android:textColor=\"#FFCC00\" android:textSize=\"16sp\" android:id=\"@+id/bt_1\" android:background=\"@drawable/open\" android:layout_height=\"50dp\"&gt; &lt;/Button&gt; &lt;TextView android:layout_width=\"wrap_content\" android:textSize=\"30sp\" android:text=\"这是一个文本框\" android:id=\"@+id/text_1\" android:layout_height=\"wrap_content\"&gt; &lt;/TextView&gt; &lt;EditText android:layout_width=\"wrap_content\" android:hint=\"请输入名称\" android:id=\"@+id/edit_1\" android:maxLines=\"2\" android:layout_height=\"wrap_content\"&gt; &lt;/EditText&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:id=\"@+id/img_1\" android:src=\"@drawable/open\" android:layout_height=\"wrap_content\"&gt; &lt;/ImageView&gt; &lt;SeekBar android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;/SeekBar&gt;&lt;/LinearLayout&gt; 其他属性设置 布局方向：LinearLayout为线性布局，默认从左往右排列android:orientation=\"horizontal\"，可更改属性为垂直排列android:orientation=\"vertical\"； 居中排列：android:gravity=\"center\" 边缘空隙：android:layout_margin=\"20dp\" 权重（排列间隔）：android:layout_weight=\"1\" 线性排列内部居中：android:layout_gravity=\"center\"","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（一）","slug":"零基础快速学习Android开发（一）","date":"2020-08-16T16:44:43.292Z","updated":"2020-08-18T08:56:27.689Z","comments":true,"path":"2020/08/17/零基础快速学习Android开发（一）/","link":"","permalink":"http://xaviermin.github.io/2020/08/17/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Android介绍android开发是指android平台上应用的制作，Android早期由“Android之父”之称的Andy Rubin创办，Google于2005年并购了成立仅22个月的高科技企业Android，展开了短信、手机检索、定位等业务，基于Linux的通用平台进入了开发。Android是一种基于Linux的自由及开放源代码的操作系统，Android 分为四个层，从高层到低层分别是应用程 序层、应用程序框架层、系统运行库层和 Linux 内核层。","text":"Android介绍android开发是指android平台上应用的制作，Android早期由“Android之父”之称的Andy Rubin创办，Google于2005年并购了成立仅22个月的高科技企业Android，展开了短信、手机检索、定位等业务，基于Linux的通用平台进入了开发。Android是一种基于Linux的自由及开放源代码的操作系统，Android 分为四个层，从高层到低层分别是应用程 序层、应用程序框架层、系统运行库层和 Linux 内核层。 Android开发环境的搭建1.下载并安装配置jdk1.1下载jdk下载链接：Java SE Downloads 1.2安装、配置jdk由于之前实习学过Java的开发，安装过jdk并在电脑上已经配置好了的，这里就不详细面熟，网上有很多安装jdk的教程，可参考其他博客，推荐博客Android Studio开发环境搭建全攻略。 2.下载并安装Android Studio2.1下载Android studio下载链接：Android Studio 2.2安装Android studio这里遇到个问题，理论上这个界面安装时候会有Android SDK选项，但此处没有，先按步骤安装完程序，后面再解决这个问题。 点击Next，选择想要安装的路径，一路next。 安装完成后显示successfully。 安装成功后启动程序，会跳出这个对话框，如果是首次安装，选择Do not import settings，不导入之前版本的配置，如果以前安装过，且没有删除以前的配置信息，就选择Config or installation folder，然后点击OK，随后程序启动。 对话框询问，是否允许谷歌收集你使用Android Studio记录信息，以此帮助他们来优化软件，可以自行选择，我选择Don’t send。 显示无法访问到Android的SDK，先点击Cancel，这就是最开始提到的问题，没有安装Android SDK选项。 点击Cancel后，然后进入到了AndroidStudio的安装向导界面，点击next。 这里选择自定义安装，为的是后续我的SDK可以自行指定安装路径。 然后进入界面主题选择页面，我选择Darcula主题，喜欢亮度较高的主题可选择Light，然后点击下一步。 这里需要指定SDK的本地路径，如果之前电脑中已经存在SDK，可以指定该路径，后续就可以不用下载SDK，只会更新SDK；因为我是首次安装Android Studio，所以演示本地没有安装过SDK的场景，这里可以指定一个后续保存SDK的路径。 默认，下一步。 点击Finish，进行安装，这一步必须保证电脑在联网状态。 下载好以后，点击Finish，进入Android Studio的欢迎页面。 至此，AndroidStudio已经安装成功。安装完成后，以建立一个Helloworld项目为例，单击上图中的Start a new Android Studio project新建一个工程，进入下面的界面。 2.2 Android studio环境变量配置 首先右键我的电脑，点击【属性】，打开高级系统设置 点击【环境变量】，在系统变量下点击新建 添加变量名SDK_HOME和变量sdk位置 在系统变量里找到变量path，对其进行编辑，win10系统直接在列表中新建path变量：%SDK_HOME%\\tools 和 %SDK_HOME%\\platform-tools。如果你的系统中path变量为非列表形式，变量之间要用分号；隔开。 接下来检查SDK是否配置成功，使用 Windows+R 键，再输入cmd启动windows命令行界面，运行命令adb，出现以下信息表示SDK配置成功。 3.Gradle的下载与配置 Android Studio使用Gradle的目的在于帮助开发者管理项目依赖，开发部署，代码复用。 Gradle是一种构建工具，可以帮助开发者管理项目中的差异，依赖，编译，打包，部署等，可以定义满足自己需要的构建逻辑，写入到build.gradle中供日后复用。 Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven、Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。 3.1 下载Gradle先看需要安装哪个版本的gradle，不同版本的Android Studio应该是对应不同版本的gradle。 随便打开一个安卓工程，点击Help-&gt;About查看Android Studio版本 在工程根目录下打开gradle\\wrapper\\gradle-wrapper.properties，查看gradle版本，我的是gradle-6.1.1-all.zip。 1distributionUrl=https\\://services.gradle.org/distributions/gradle-6.1.1-all.zip 可在gradle主页下载相应版本的压缩包，一般地，在打开一个Android工程，如果没有下载安装gradle，软件会自动联网下载，但通常情况下下载都会非常慢，推荐在网上直接搜索需要的gradle版本进行下载，我是在CSDN下载的，有很多资源，如这个博客。 3.2 配置将下载好的gradle压缩包放在C:\\Users\\ASUS LD\\.gradle\\wrapper\\dists\\gradle-6.1.1-all\\cfmwm155h49vnt3hynmlrsdst目录下，正常情况下这里面还有.zip.lck和.zip.ok两个文件，并解压缩。 在Files-&gt;Settings中找到Gradle的配置，如果选择了下面的 Use Gradle from Specified location，那么就得检查目录是否设置正确，此时地址是C:\\Users\\ASUS LD\\.gradle\\wrapper\\dists\\gradle-6.1.1-all。 3.3 环境变量的添加这一步是我在安装的过程中，看到网上有些博主说的，不知道有没有用，反正我添加了… 在我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建系统变量，变量名为GRADLE_HOME，变量值为解压后的gradle文件中的bin目录下。 在Path中添加%GRADLE_HOME%\\bin，确定 环境变量添加完成。","categories":[],"tags":[]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2020-08-13T14:04:36.463Z","updated":"2021-01-03T17:28:14.157Z","comments":true,"path":"2020/08/13/Markdown常用语法/","link":"","permalink":"http://xaviermin.github.io/2020/08/13/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"什么是MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字。","text":"什么是MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 1.基本语法1.1 字体设置斜体、粗体、删除线语法如下： *这里是文字* _这里是文字_ //倾斜 **这里是文字** //加粗 ***这里是文字*** //倾斜加粗 ~~这里是文字~~ //删除线效果如下：这里是文字 这里是文字这里是文字这里是文字这里是文字 1.2 分级标题语法如下： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题1.3 链接语法如下： 直接显示网址链接：&lt;网址&gt; 插入超链接：文字+链接网址 插入图片：见另一篇博客（Markdown添加图片） 1.4 分割线语法如下：在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西，也可以在星号，或是减号中间插入空格。 1.5 代码块语法如下： 利用缩进(tab),首行缩进一个字符。 利用英文 ``` 符号包裹代码。` 行内式：main` 直接运行html代码 1.6 引用语法如下： 1.在被引用的文本前加上&gt;符号，以及一个空格，如果只输入了一个&gt;符号会产生一个空白的引用。 2.引用的嵌套使用效果如下： 文字 文字 1.7 列表语法如下： 1.无序列表：使用*，+，-，后加一个空格，再加文字。 2.有序列表：使用数字和一个英文句点。 3.列表嵌套：上一级和下一级之间敲三个空格即可。效果如下： 列表文字 列表文字 列表文字 列表文字 列表文字 列表文字 列表文字 列表文字 1.8 表格语法如下： 文字|文字|文字 -|-|- :-:|:-:|:-: -:|-:|-: //左对齐 居中 右对齐 文字|文字|文字 文字|文字|文字效果如下： 文字 文字 文字 文字 文字 文字 文字 文字 文字 2.快捷键 功能 快捷键 加粗 Ctrl+B 斜体 Ctrl+I 引用 Ctrl+Q 插入链接 Ctrl+L 插入代码 Ctrl+K 插入图片 Ctrl+G 提升标题 Ctrl+H 有序列表 Ctrl+O 无序列表 Ctrl+U 横线 Ctrl+R 撤销 Ctrl+Z 重做 Ctrl+Y 3.特殊用法3.1 制作一份待办事宜 语法如下： - [ ] 文字 待办 - [x] 文字 已办 ​ 效果如下： 文字 文字 3.2 书写公式语法如下： $$公式$$3.3 绘制流程图语法如下： 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op效果如下： 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 3.4 绘制序列图语法如下： 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!3.5 绘制甘特图语法如下： 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d","categories":[],"tags":[]},{"title":"Markdown添加图片","slug":"Markdown添加图片","date":"2020-08-12T13:47:39.144Z","updated":"2020-08-13T08:36:43.401Z","comments":true,"path":"2020/08/12/Markdown添加图片/","link":"","permalink":"http://xaviermin.github.io/2020/08/12/Markdown%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/","excerpt":"百度Markdown添加图片，看到最多的就是以下这几种方法,各种Markdown编辑器的插图方式也都包含在这几种方法之内。插图的基础格式：![text](图片链接 \"optional title\") text：图片的Alt标签，用来描述图片的关键词，可以不写。 图片链接：可以是图片的本地地址或者是网址。 “optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。","text":"百度Markdown添加图片，看到最多的就是以下这几种方法,各种Markdown编辑器的插图方式也都包含在这几种方法之内。插图的基础格式：![text](图片链接 \"optional title\") text：图片的Alt标签，用来描述图片的关键词，可以不写。 图片链接：可以是图片的本地地址或者是网址。 “optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。 1.插入本地图片只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。 格式为：![text](本地文件路径) 缺点：不灵活不好分享，本地图片的路径更改或丢失都会造成markdown文件调不出图。 2.插入网络图片只需要在基础语法的括号中填入图片的网络链接即可，现在已经有很多免费/收费图床和方便传图的小工具可选。 格式为：![text](网络图片路径) 缺点：将图片存在网络服务器上，非常依赖网络。 3.把图片存入markdown文件用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 格式为：![text][base64str] 缺点：有点麻烦，需要将图片转化为base64字符串，用到Python 使用python将图片转化为base64字符串 12345import base64f=open('723.png','rb') #二进制方式打开图文件ls_f=base64.b64encode(f.read()) #读取文件内容，转换为base64编码f.close()print(ls_f) base64字符串转化为图片 123456import base64bs='iVBORw0KGgoAAAANSUhEUg....' # 太长了省略imgdata=base64.b64decode(bs)file=open('2.jpg','wb')file.write(imgdata)file.close() 4.利用Github在Markdown中插入图片利用GitHub上传图片，并在Markdown中插入是较为稳妥和方便的方法，使用GitHub上传图片，主要分为4步： 1.先注册一个github的帐号 2.创建一个专门放图片的仓库 3.上传图片 4.上传完成后，点击打开图片，右键复制图片链接，加入到Markdown文件中 具体步骤参考这篇博客详细介绍，我尝试这种方法在GitHub上传完照片后点击图片显示不出来，按照百度的解决办法操作后，GitHub网站又进不去…放弃了，也不知道图片显示不了的问题解决没，而且向GitHub上传图片的操作有点麻烦，上传完照片每次取连接也不方便。 5.将图片上传至图床把写博客需要的所有图片保存到某个图床服务里，然后获取该图片的网络图床链接写在博客里，就可以显示图片了，相当于插入网络图片。我使用的是路过图床，提供高速稳定的图片上传和分享服务，而且免费！！！ 步骤如下： 1.路过图床官网注册账号 2.上传图片到图床 3.将图片URL链接添加到Markdown文件中就可以显示出图片了 推荐使用这种方法，上传图片方便快捷，可批量上传，上传后的图片一直保存在图床就OK。","categories":[],"tags":[]},{"title":"Hexo博客页面美化","slug":"Hexo博客页面美化","date":"2020-08-12T07:32:42.030Z","updated":"2020-08-13T16:58:09.211Z","comments":true,"path":"2020/08/12/Hexo博客页面美化/","link":"","permalink":"http://xaviermin.github.io/2020/08/12/Hexo%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/","excerpt":"前言：原来的界面使用的是yilia主题，下面采用volantis主题进行美化设计，博客主题可在Themes网站下载喜欢的，下载好的压缩包添加到博客文件内的themes文件夹中，修改_config.yml文件主题名称，原博客主题界面如下图所示。","text":"前言：原来的界面使用的是yilia主题，下面采用volantis主题进行美化设计，博客主题可在Themes网站下载喜欢的，下载好的压缩包添加到博客文件内的themes文件夹中，修改_config.yml文件主题名称，原博客主题界面如下图所示。 一、页面优化1.导航栏样式在原基础上添加了一个渐变背景。首先在主题配置文件_config.yml中navbar的effext毛玻璃特效（blur）去掉。 123456将第5行改成第6行：navbar: height: 64px width: auto # auto, max effect: [shadow, blur] # [shadow, floatable, blur] effect: [shadow] # [shadow, floatable] 在themes\\volantis\\source\\css_layout\\navbar.styl中，添加代码 123456789101112添加第11行代码：.l_header $iconW = 32px $iconMargin = 4px position: fixed z-index: 1000 top: 0 width: 100% height: $navbar-height background: $color-card background-image: linear-gradient(to top, #5ee7df 0%, #b490ca 100%) box-shadow: $boxshadow-card #5ee7df0%, #b490ca100%中的#5ee7df、#b490ca代表两种颜色，从0%到100%渐变，可修改这两个参数改变颜色，免费的CSS渐变背景样式网站——CSS渐变背景。 效果如下： 2.页面卡片阴影在主页面中的文章、侧边栏添加一点阴影，并在鼠标悬停时出现阴影。 主页文章：在\\themes\\volantis\\source\\css\\_layout中main.styl文件，找到.post-wrapper属性 123456789添加5-9行代码：.post-wrapper column-break-inside: avoid break-inside: avoid-column box-shadow: 0 1px 20px -6px rgba(0,0,0,0.5) border-radius: 8px transition: box-shadow .5s ease &amp;:hover box-shadow:0px 1px 20px 1px rgba(0,0,0,0.5) 侧边栏：在themes\\volantis\\source\\css_layout中sidebar.styl文件，找到.widget属性 123456789101112添加9-12行代码：.widget z-index: 0 background: $color-card margin-top: $gap border-radius: $border-card width: 100% display: none box-shadow: 0 1px 20px -6px rgba(0,0,0,0.5) transition: box-shadow .5s ease &amp;:hover box-shadow:0px 1px 20px 1px rgba(0,0,0,0.5) 效果如下： 3.页面特效在themes\\volantis\\layout中layout.ejs文件的body里面直接引用，添加鼠标点击社会主义价值观特效和鼠标滑动特效。 12345678添加7、8行代码：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;%- partial('_partial/head') %&gt;&lt;body&gt; &lt;%- partial('_partial/cover') %&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/zyoushuo/Blog/hexo/js/clicksocialist.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/zyoushuo/Blog/hexo/js/mouse_slide.js\"&gt;&lt;/script&gt; 效果如下： 4.主页、正文文章标题居中在themes\\volantis\\source\\css_layout\\main.styl中添加代码，使得主页面的文章、文章正文、关于/友链/留言板等自定义页面的标题居中。 123456789添加第9行代码：.post-wrapper margin-bottom: $gap .post div.meta margin-bottom: $gap .title font-size: $fontsize-h2+ text-align: center 123456添加第5行代码： .title trans(.1s) margin: 0+ text-align: center color: $color-text 5.修改卡片的内外边距在_config.yml文件中找到.gap的设置，添加base值，大小为要设置的内外边距。 12345678修改代码：gap: base: 10px h2: 48px # Spacing above H2 (only px unit) h3: 24px # Spacing above H3 (only px unit) h4: 16px # Spacing above H4 (only px unit) line: .51rem # 段落行间距 inline: .5rem # 段落内部行间距 6.修改侧边栏头像在_config.yml文件中找到avatar的设置，将原头像地址改成想要换的头像地址，前提是头像图片是网络图片，大小在150x150适中，形状可在shape处改成圆形或矩形。 12345678910111213# widget librarywidget: blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://s1.ax1x.com/2020/08/13/dS4nTs.png # avatar: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png shape: rectangle # circle, rectangle url: /about/ title: subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: true 页面中有些地方使用的小图标在网站Font Awesome中获取。 7.文章末尾版权 参考博客： 1.Volantis主题DIY笔记 2.hexo之Volantis主题美化 3.","categories":[],"tags":[]},{"title":"Python入门笔记","slug":"Python入门笔记","date":"2020-08-11T20:33:37.873Z","updated":"2020-08-22T18:02:54.054Z","comments":true,"path":"2020/08/12/Python入门笔记/","link":"","permalink":"http://xaviermin.github.io/2020/08/12/Python%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","excerpt":"1. Python基本语法元素1.1 编译和解释（程序执行的两种方式） 编译：将源代码一次性转换成目标代码的过程。 解释：将源代码逐条转换成目标代码同时逐条运行的过程。（类似实时的同声传译） 根据程序这两种执行方式，可以将编程语言分为两类：静态语言和脚本语言。 静态语言：C/C++、Java语言等。编译器一次性生成目标代码，优化更充分，程序运行速度更快。 脚本语言：Python、JavaScript、PHP等。执行程序时需要源代码，维护更灵活，同时保留源代码可以使程序功能可跨多个操作系统平台运行。","text":"1. Python基本语法元素1.1 编译和解释（程序执行的两种方式） 编译：将源代码一次性转换成目标代码的过程。 解释：将源代码逐条转换成目标代码同时逐条运行的过程。（类似实时的同声传译） 根据程序这两种执行方式，可以将编程语言分为两类：静态语言和脚本语言。 静态语言：C/C++、Java语言等。编译器一次性生成目标代码，优化更充分，程序运行速度更快。 脚本语言：Python、JavaScript、PHP等。执行程序时需要源代码，维护更灵活，同时保留源代码可以使程序功能可跨多个操作系统平台运行。 1.2 求解计算问题的精简步骤 确定IPO：明确计算部分及功能边界。 编写程序：将计算求解的设计变成现实。 调试程序：确保程序按照正确逻辑能够正确运行。 1.3 Python的两种编程方式 交互式：对每个输入语句即时运行结果，适合语法练习。 文件式：批量执行一组语句并运行结果，是编程的主要方式。 1.4 实例1：温度转换编写程序实现，输入摄氏温度，转换成华氏温度输出，输入华氏温度转换成摄氏温度输出。 12345678910#Tem_change.pyTempStr = input (\"请输入带有符号的温度值: \")if TempStr[-1] in ['F', 'f'] : C = (eval(TempStr[0:-1]) - 32) / 1.8 print(\"转换后的温度是{:.2f}C\".format(C))elif TempStr[-1] in ['C', 'c'] : F = 1.8 * eval(TempStr[0:-1]) + 32 print(\"转换后的温度是{:.2f}F\".format(F))else: print(\"输入格式错误，请重新输入！\") 分别输入36C、88F，程序输出结果分别为96.80F、31.11C。 1.5 Pythonn程序语法元素分析 单行注释：以#开头，其后内容为注释。 多行注释：以'''开头和结尾。 字符串表示：TempStr[-1]表示TempStr字符串的最后一个字符 切分：TempStr[0:-1]表示TempStr字符串从第一个字符开始但不到最后一个字符 print函数：例print(“转换后的温度是{:.2f}F”.format(F))，{:.2f}表示槽，后续变量填充到槽中，此处将变量F填充到这个位置并取小数点后两位。 eval函数（评估函数）：去掉参数最外侧引号并执行余下语句的函数。123456789例子：&gt;&gt;&gt;eval(\"1\")1&gt;&gt;&gt;eval(\"1+2\")3&gt;&gt;&gt;eval('\"1+2\"')'1+2' #输出只保留单引号&gt;&gt;&gt;eval('print(\"Hello\")')Hello format函数：一种格式化输出字符串的函数（str.format）,基本语法是通过｛｝和：来代替以前的%。详细参考[format函数之几种常规用法][1] 2. Python基本图形绘制2.1 实例2：Python蟒蛇绘制这是Python蟒蛇绘制的全部代码，第2行impor是保留字，引入了一个绘图库turtle。 1234567891011121314151617#Snake_fig.pyimport turtleturtle.setup(650, 350, 200, 200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(\"red\")turtle.seth(-40)for i in range(4): turtle.circle(40, 80) turtle.circle(-40, 80)turtle.circle(40, 80/2)turtle.fd(40)turtle.circle(16, 180)turtle.fd(40 * 2/3)turtle.done() 2.2 turtle库的使用turtle（海龟）库是turtle绘图体系的Python实现。 turtle的绘图窗体：turtle.setup(width, height, startx, starty)，setup()设置窗体大小及位置，(startx, starty)两个参数省略系统默认窗口在屏幕正中心。 前进：turtle.fd(d)，fd() 括号里输入前进距离。 旋转角度：turtle.seth(angle)，seth()，括号里输入旋转的角度。 画圆：turtle.circle(r, angle)，表示以当前位置左侧某一点为圆心，进行曲线运动。 方向控制函数：turtle.seth(angle)，改变行径方向，angle为绝对坐标角度。 循环语句：for i in range(4):，循环4次，range()函数产生循环计数序列。range(N)即产生0到N-1的整数序列，共N个；range(M,N)产生M到N-1的整数序列，共N-M个。 done函数：turtle.done()，文件式描写方法中，该函数作为turtle绘制的最后一部分，程序运行之后程序不会退出，需要手工关闭窗体退出。 3. 基本数据类型3.1 数字类型及操作 整数类型：pow(x,y)函数，计算x的y次方。 浮点数类型：带有小数点及小数的数字，浮点数间运算存在不确定尾数（不是bug）。浮点数间运算及比较用round(x,d)函数辅助，对x四舍五入，d是小数截取位数，不确定尾数一般发生在10e-16（aeb表示a*10的b次方）左右。 复数类型：与数学中复数的概念一致。 数值运算操作符： 操作符及使用 描述 x+y 加，x与y之和 x-y 减，x与y之差 x*y 乘，x与y之积 x/y 除，x与y之商 10/3结果是3.3333333333333335 x//y 整数除，x与y之整数商 10/3结果是3 +x x本身 -y y的负值 x%y 余数，模运算 10%3结果是1 x**y 幂运算，x的y次幂，当y是小数时为开放运算 数值运算函数： 函数及使用 描述 abs(x) 绝对值，x的绝对值 abs(-10)结果为10 divmod(x,y) 商余，(x//y,x%y)，同时输出商和余数，divmod(10,3)结果为(3,1) pow(x,y[,z]) 幂余，(x**y)%z，pow(3,pow(3,99),10000)结果为4587 round(x,d) 四舍五入，d是保留小数位数，round(-10.123,2)结果为-10.12 max(X1,X2,…,Xn) 最大值，返回X1,X2,…,Xn中最大值，n不限 min(X1,X2,…,Xn) 最小值，返回X1,X2,…,Xn中最小值，n不限 int(x) 将x变成整数，舍弃小数部分，也可将字符型变成整数 float(x) 将x变成浮点数，增加小数部分，也可将字符型变成浮点数 complex(x) 将x变成复数，增加虚数部分 3.2 字符串类型及操作 字符串切片用法： &lt;字符串&gt;[M:N]，M缺失表示至开头，N缺失表示至结尾。例：”一二三四五六七八九” [:3]结果是”一二三”&lt;字符串&gt;[M:N:K]，根据步长K对字符串切片。例：”一二三四五六七八九” [1:8:2]结果是”二四六八”“一二三四五六七八九” [::-1]结果是”九八七六五四三二一” 字符串操作符： 操作符及使用 描述 x+y 连接两个字符串x和y nx 或 xn 复制n次字符串x x in s 如果x是s的子串，返回True，否则返回False 字符串处理函数： 函数及使用 描述 len(x) 长度，返回字符串x的长度，len(“一二三456”)结果为6 str(x) 任意类型x所对应的字符串形式，str(1.23)—“1.23”，str([1,2])—[1,2]，与eval()函数功能相反。 hex(x)或oct(x) 整数x的十六进制或八进制小写形式字符串，hex(425)—“0x1a9”，oct(425)—“0o651” chr(u) u为Unicode编码，返回其对应的字符 ord(x) x为字符，返回其对应的Unicode编码 字符串处理方法： 方法及使用 描述 str.lower()或str.upper 返回字符串的副本，全部字符小写/大写，”AbCdEfGh”.lower()结果为”abcdefgh” str.split(sep=None) 返回一个列表，由str根据sep被分隔的部分组成，”A,BC,DEF”.split(“,”)结果为[‘A’,’BC’,’DEF’] str.count(x) 返回子串x在str中出现的次数，”i love you”.count(“o”)结果为2 str.replace(old,new) 返回字符串str副本，所有old子串被替换为new，”python”.replace(“n”,”n123.io”)结果为”python123.io” str.center(width[,fillchar]) 字符串str根据宽度width居中，fillchar可选，”python”.center(20,”=”)结果为”=======python=======” str.strip(chars) 从str中去掉chars中列出的字符，”= python “.strip(“ np”)结果为”ytho” str.join(iter) 在iter变量除最后元素外每个元素后增加一个str，”,”.join(“12345”)结果为”1,2,3,4,5” 字符串类型的格式化：格式化是对字符串进行格式表达的方式，使用.format()方法,共有6个控制格式，分别为填充、对齐、宽度、,、.精度、类型，用法如下 &lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)例：“{0:=^20}”.format(“PYTHON”)——“=======PYTHON=======”“{0:&gt;20}”.format(“PYTHON”)——“*****PYTHON”“{:10}”.format(“PYTHON”)——“PYTHON “ #默认左对齐“{0:,.2f}”.format(12345.6789)——‘12,345.68’“{0:b},{0:d},{0:o},{0:x},{0:X}”.format(425)——‘110101001,425,651,1a9,1A9’“{0:e},{0:f},{0:%}”.format(3.14)——‘3.140000e+00,3.140000,314.000000%’ 3.3 time库的使用 time库基本介绍：是Python中处理时间的标准库。123456import timetime.&lt;b&gt;()##### time库包括三类函数 #####1.时间获取：time() ctime() gmtime()2.时间格式化：strftime() strptime()3.程序计时：sleep() perf_counter() 时间获取： 函数 描述 time() 获取当前时间戳，即计算及内部时间值，浮点数，表示从1970年1月1日0:00开始到当前时刻为止以秒为单位的数值，1596959041.034725 ctime() 获取当前时间并以易读方式表示，返回字符串，’Sun Aug 9 15:44:30 2020’ gmtime() 获取当前时间，表示为计算机可处理的时间格式，time.struct_time(tm_year=2020, tm_mon=8, tm_mday=9, tm_hour=7, tm_min=45, tm_sec=41, tm_wday=6, tm_yday=222, tm_isdst=0) 时间格式化： 函数 描述 strftime(tpl,ts) tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量，&gt;&gt;&gt;t=time.gmtime()&gt;&gt;&gt;time.strftime(“%Y-%m-%d %H:%M:%S”,t)输出’2020-08-09 07:52:17’ strptime(str,tpl) str是字符串形式的时间值，tpl是格式化模板字符串，用来定义输入效果，&gt;&gt;&gt;timeStr = ‘2020-08-09 16:03:30’&gt;&gt;&gt;time.strptime(timeStr, “%Y-%m-%d %H:%M:%S”)输出time.struct_time(tm_year=2020, tm_mon=8, tm_mday=9, tm_hour=16, tm_min=3, tm_sec=30, tm_wday=6, tm_yday=222, tm_isdst=-1) 各字符代表的含义如下表所示： 格式化字符串 日期/时间说明 格式化字符串 日期/时间说明 %Y 年份 %m 月份（数字） %B 月份名称 %b 月份名称缩写 %d 日期 %A 星期 %p 上/下午 %a 星期缩写 %H 小时（24h制） %I 小时（12h制） %M 分钟 %S 秒 程序计时应用： 函数 描述 perf_counter() 测量时间函数，返回CPU级别的精确时间计数值，单位为秒，由于计数值起点不确定，连续调用取差值才有意义 sleep(s) 产生时间函数，s为休眠的时间，单位秒，可以是浮点数 3.4 实例：文本进度条1.文字显示进度，代码如下： 12345678910111213141516171819202122232425import timescale = 10print(\"=====执行开始=====\")for i in range(scale+1): a = '*' * i b = '.' * (scale - i) c = (i/scale) * 100 print(\"{:^3.0f}%[{}-&gt;{}]\".format(c,a,b)) time.sleep(0.1)print(\"=====执行结束=====\")运行效果：=====执行开始===== 0 %[-&gt;..........]10 %[*-&gt;.........]20 %[**-&gt;........]30 %[***-&gt;.......]40 %[****-&gt;......]50 %[*****-&gt;.....]60 %[******-&gt;....]70 %[*******-&gt;...]80 %[********-&gt;..]90 %[*********-&gt;.]100%[**********-&gt;]=====执行结束===== 2.单行动态刷新，代码如下： 1234567import timefor i in range(101): print(\"\\r当前进度{:}%\".format(i), end=\"\") time.sleep(0.1) 运行效果：当前进度66% #直到100% 3.完整版单行动态刷新，代码如下： 1234567891011121314151617import timescale = 50print(\"执行开始\".center(scale//2, \"=\"))start = time.perf_counter()for i in range(scale+1): a = '*' * i b = '.' * (scale - i) c = (i/scale) * 100 dur = time.perf_counter() - start print(\"\\r{:^3.0f}%[{}-&gt;{}]{:.2f}\".format(c,a,b,dur), end=\"\") time.sleep(0.1)print(\"\\n\" + \"执行结束\".center(scale//2, \"=\"))运行效果：===========执行开始==========100%[**************************************************-&gt;]5.03===========执行结束========== 4. 程序的控制结构4.1 程序的分支结构1234567if &lt;条件&gt;: # :不能漏 &lt;语句块&gt;#二(多)分支结构if &lt;条件&gt;: &lt;语句块1&gt;else: &lt;语句块2&gt; 程序的异常处理，结构如下： 1234567891011try : &lt;语句块1&gt;except : #可添加异常类型标记，except &lt;异常类型&gt;: &lt;语句块2&gt; #例:try : num = eval(input(\"请输入一个整数:\")) print(num**2)except : #except NameError: NameError为一种异常类型名称 print(\"输入的不是整数\") 4.2 程序的循环结构 遍历循环（for循环）：遍历某个结构形式的循环运行方式。 123456789101112131415for &lt;循环变量&gt; in &lt;遍历结构&gt; : # : 不能漏 &lt;语句块&gt; 1.计数循环（N次）for i in range(M,N,K) : #从M到N，以K为步长 &lt;语句块&gt;2.字符串遍历循环for c in s : &lt;语句块&gt;3.列表遍历循环for item in ls : &lt;语句块&gt;4.文件遍历循环for line in fi : &lt;语句块&gt; 无限循环（while循环）：由条件控制的循环运行方式。 12while &lt;条件&gt; : &lt;语句块&gt; 循环控制保留字：break和continuebreak：跳出并结束当前整个循环，执行循环后的语句。continue：结束当次循环，继续执行后续次数循环。 4.3 random库的使用random库是使用随机数的Python标准库，用于生成随机数，使用方法import random。基本随机数函数：seed(),random()扩展随机数函数：randint(),getrandbits(),uniform(),randrange(),choice(),shuffle() 函数 描述 seed(a=None) 初始化给定的随机数种子，默认为当前系统时间，&gt;&gt;&gt;random.seed(10) #产生种子10对应的序列 random() 生成一个[0.0,1.0]之间的随机小数，&gt;&gt;&gt;random.random()&gt;&gt;&gt;0.9363138024400508 randint(a,b) 生成一个[a,b]之间的整数，&gt;&gt;&gt;random.randint(10,100)&gt;&gt;&gt;51 randrange(m,n[,k]) 生成一个[m,n]之间以k为步长的随机整数，&gt;&gt;&gt;random.randrange(10,100,10)&gt;&gt;&gt;70 uniform(a,b) 生成一个[a,b]之间的随机小数，&gt;&gt;&gt;random.uniform(10,100)&gt;&gt;&gt;46.482745366926494 getrandbits(k) 生成一个k比特长的随机整数，&gt;&gt;&gt;random.getrandbits(5)&gt;&gt;&gt;27 choice(seq) 从序列seq中随机选择一个元素，&gt;&gt;&gt;random.choice([1,2,3,4,5])&gt;&gt;&gt;3 shuffle(seq) 将序列seq中元素随机排列，返回打乱后的顺序，&gt;&gt;&gt;s=[1,2,3,4,5];random.shuffle(s);print(s)&gt;&gt;&gt;[1, 2, 4, 3, 5] 5. 函数和代码复用5.1 函数的定义与使用 函数的理解与定义 函数是一段代码的表示、是一段具有特定功能的可重用的语句组、是一种功能的抽象、降低编程难度和代码复用。 12345678910def &lt;函数名&gt;(&lt;参数(0个或多个)&gt;) : &lt;函数体&gt; return &lt;返回值&gt; 例：计算n！def fact(n) : s = 1 for i in range(1, n+1): s *= i return s 局部变量和全局变量使用规则： 1.基本数据类型，无论是否重名，局部变量与全局变量不同2.可以通过global保留字在函数内部声明全局变量3.组合数据类型，如果局部变量未真实创建，则是全局变量 lambda函数 lambda函数返回函数名作为结果 12345678910&lt;函数名&gt; = lambda &lt;参数&gt; : &lt;表达式&gt;例：f = lambda x, y : x + yf(10, 15)25f = lambda : \"lambda函数\"print(f())lambda函数 5.2 实例：七段数码管的绘制主要是熟悉函数的定义与调用，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import turtle, timedef drawGap() : #每段数码管添加间隔，更美观 turtle.penup() turtle.fd(5)def drawLine(draw) : #绘制单段数码管 drawGap() turtle.pendown() if draw else turtle.penup() turtle.fd(40) drawGap() turtle.right(90)def drawDigit(digit) : #根据数字绘制七段数码管 drawLine(True) if digit in [2, 3, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 1, 3, 4, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 3, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 6, 8] else drawLine(False) turtle.left(90) drawLine(True) if digit in [0, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 3, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 1, 2, 3, 4, 7, 8, 9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20)# def drawData(data) : #获取要输出的数字# for i in data :# drawDigit(eval(i)) #通过eval()函数将数字变为整数def drawData(data) : #data为日期，格式为'%Y-%m=%d+' turtle.pencolor(\"red\") for i in data : if i == '-' : turtle.write('年', font=(\"Arial\", 24, \"normal\")) turtle.pencolor(\"green\") turtle.fd(40) elif i == '=' : turtle.write('月', font=(\"Arial\", 24, \"normal\")) turtle.pencolor(\"blue\") turtle.fd(40) elif i == '+' : turtle.write('日', font=(\"Arial\", 24, \"normal\")) else: drawDigit(eval(i))def main() : turtle.setup(800, 350, 200, 200) turtle.penup() turtle.fd(-300) turtle.pensize(5) # drawData('20200810') drawData(time.strftime('%Y-%m=%d+', time.gmtime())) turtle.hideturtle() turtle.done()main() 5.3 代码复用与函数递归 函数递归的理解：即函数调用函数自身，比如计算阶乘n*(n-1)!。 函数递归实例：字符串反转12345678910111213141516def rvs(s) : #字符串反转函数 if s == \"\" : return s else : return rvs(s[1:])+s[0]def main() : s = input (\"请输入字符串: \") st = rvs(s) print(\"反转后的字符串为：{}\".format(st))main()运行效果：请输入字符串: 123456789反转后的字符串为：987654321 5.4 Pyinstaller库的使用Pyinstaller库是第三方库，可将源代码转换成无需源代码的可执行文件。 安装Pyinstaller库：Windows环境下打开cmd命令行，输入pip install pyinstaller命令，pip指令安装库的时候连接互联网，从互联网上自动下载安装包，并安装执行，安装之后会提示Successfully installed即安装完成。 Pyinstaller库使用：以七段数码管为例，文件名为seg.py，在该文件所在目录下执行命令pyinstaller -F seg.py,转换成功后在所在文件夹中会新增名为dist文件夹，里面有seg.exe可执行程序，双击即可。 Pyinstaller库常用参数： 参数 描述 -h 查看帮助 –clean 清理打包过程中的临时文件 -D 默认值，生成dist文件夹 -F 在dist文件夹中只生成独立的.exe文件（推荐使用） -i &lt;图标文件名.ico&gt; 指定打包程序使用的图标（ico）文件，例：pyinstaller -i xxx.ico -F seg.py 6. 组合数据类型6.1 集合类型及操作 集合三重点： 1.集合用大括号{}表示，元素间用逗号分隔2.集合中每个元素唯一，不存在相同元素3.集合元素之间无序 6个操作符 操作符及应用 描述 S1T(1表竖线) 并，返回一个新集合，包括在集合S和T中的所有元素 S-T 差，返回一个新集合，包括在集合S但不在T中的元素 S&amp;T 交，返回一个新集合，包括同时在集合S和T中的元素 S^T 补，返回一个新集合，包括集合S和T中的非相同元素 S&lt;=T或S&lt;T 返回True/False，判断S和T的子集关系 S&gt;=T或S&gt;T 返回True/False，判断S和T的包含关系 集合处理方法 操作函数或方法 描述 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x，如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S中的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回集合S的一个副本 len(S) 返回集合S的元素个数 x in S 判断S中元素x，x在集合S中，返回True，否则返回False x not in S 判断S中元素x，x不在集合S中，返回True，否则返回False set(x) 将其他类型变量x转变为集合类型 6.2 序列类型及操作 序列类型：序列是具有先后关系的一组元素 1.序列是一维元素向量，元素类型可以不同2.元素间由序号引导，通过下标访问序列的特定元素 6个操作符 操作符及应用 描述 x in s 如果x是序列s的元素，返回True，否则返回False x not in s 如果x是序列s的元素，返回False，否则返回True s+t 连接两个序列s和t sn或ns 将序列s复制n次 s[i] 索引，返回s中的第i个元素，i是序列的序号 s[i:j]或s[i:j:k] 切片，返回序列s中第i到j以k为步长的元素子序列 序列类型通用函数和方法 5个函数和方法 描述 len(s) 返回序列s的长度 min(s) 返回序列s的最小元素，s中元素需要可比较 max(s) 返回序列s的最大元素，s中元素需要可比较 s.index(x)或s.index(x,i,j) 返回序列s从i开始到j位置中第一次出现x的位置 s.count(x) 返回序列s中出现x的总次数 元组类型：元组是序列类型的一种扩展。 1.元组是一种序列类型，一旦创建就不能修改2.使用小括号()或tuple()创建，元素间用逗号分隔3.可以使用或不适用小括号 列表类型：是序列类型的一种扩展，十分常用。 1.列表是一种序列类型，创建后可以随意被修改2.使用方括号[]或list()创建，元素间用逗号隔开3.列表中各元素类型可以不同，无长度限制 列表类型操作函数和方法 函数或方法 描述 ls[i]=x 替换列表ls第i元素为x ls[i:j:k]=lt 用列表lt替换ls切片后所对应元素子列表 del ls[i] 删除列表ls中第i元素 del ls[i:j:k] 删除列表ls中第i到第j以k为步长的元素 ls += lt 更新列表ls，将列表lt元素增加带列表ls中 ls *= n 更新列表ls，其元素重复n次 ls.append(x) 在列表ls最后增加一个元素x ls.clear() 删除列表ls中所有元素 ls.copy() 生成一个新列表，赋值ls中所有元素 ls.insert(i,x) 在列表ls的第i位置增加元素x ls.pop(i) 将列表ls中第i位置元素取出并删除该元素 ls.remove(x) 将列表ls中出现的第一个元素x删除 ls.reverse() 将列表ls中的元素反转 6.3 字典类型及操作 字典类型：是“映射”的体现。 1.映射是一种键（索引）和值（数据）的对应2.字典是键值对的集合，键值对之间无序3.采用大括号{}和dict()创建，键值对用冒号:表示 字典类型操作函数和方法 函数或方法 描述 del d[k] 删除字典d中键k对应的数据值 k in d 判断键k(索引)是否在字典d中，如果在返回True，否则返回False d.keys() 返回字典d中所有的键信息 d.values() 返回字典d中所有值信息 d.items() 返回字典d中所有键值对信息 d.get(k,’default’) 键k存在，则返回相应值，不存在则返回’default’值 d.pop(k,’default’) 键k存在，则取出相应值，不存在则返回’default’值 d.popitem() 随机从字典d中取出一个键值对，以元组形式返回 d.clear() 删除所有的键值对 len(d) 返回字典d中元素的个数 6.4 jieba库的使用jieba库：是优秀的中文分词第三方库1.中文文本需要通过分词获得单个的词语2.提供三种分词模式 安装jieba库：：Windows环境下打开cmd命令行，输入pip install jieba命令，安装之后会提示Successfully installed即安装完成。 jieba库的使用：三种模式：精确模式、全模式、搜索引擎模式 1.精确模式（最常用）：把文本精确的切分开，不存在冗余单词2.全模式：把文本中所有可能的词语都扫描出来，有冗余3.搜索引擎模式：在精确模式基础上，对长词再次切分 jieba库常用函数 函数 描述 jieba.lcut(s) 精确模式，返回一个列表类型的分词结果 jieba.lcut(s,cut_all=True) 全模式，返回一个列表类型的分词结果，有冗余 jieba.lcut_for_search(s) 搜索引擎模式，返回一个列表类型的分词结果，有冗余 jieba.add_word(w) 向分词词典增加新词w 6.5 实例：文本词频统计利用jieba库测试smartcity.txt文件的词频，代码如下 1234567891011121314151617181920212223242526import jiebatxt = open(\"smartcity.txt\", \"r\", encoding=\"utf-8\").read()words = jieba.lcut(txt)counts = {}for word in words: if len(word) == 1: continue else: counts[word] = counts.get(word, 0) + 1items = list(counts.items())items.sort(key=lambda x:x[1], reverse=True)for i in range(10): #输出前10 word, count = items[i] print(\"{0:&lt;10}{1:&gt;5}\".format(word, count)) 运行结果：城市 46创新 38智慧 30社会 16发展 14应用 12形态 11技术 10信息技术 92.0 9 程序运行过程中一直出现报错ModuleNotFoundError: No module named 'jieba'.，重新安装jieba库也不行，最后解决方式：将Python安装路径下D:\\Program Files (x86)\\Python\\Python37\\Lib\\site-packages的jieba文件夹复制到工程目录下，程序运行成功。 7. 文件和数据格式化7.1 文件的使用 文件：是数据的抽象和集合 1.文件是存储在辅助存储器上的数据序列2.文件是数据存储的一种形式3.文件展现形式：文本文件和二进制文件 文件的打开和关闭 1.打开文件：&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)文件名包括文件路径和名称，与程序文件同目录可省略路径，例\"D:/Python/f.txt\"、\"./Python/f.txt\"、\"D:\\\\Python\\\\f.txt\"、\"f.txt\"2.打开模式 文件的打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 ‘+’ 与r/w/x/a异同使用，在原功能基础上增加同时读写功能 3.关闭文件：&lt;变量名&gt;.close() 文件内容的读取 操作方法 描述 &lt;变量名&gt;.read(size=-1) 读入全部内容，如果给出参数，读入前size长度 &lt;变量名&gt;.readline(size=-1) 读入一行内容，如果给出参数，读入该行前size长度 &lt;变量名&gt;.readlines(hint=-1) 读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行 数据的文件写入 操作方法 描述 &lt;变量名&gt;.write(s) 向文件写入一个字符串或字节流，&gt;&gt;&gt;f.write(“中国是一个伟大的国家！”) &lt;变量名&gt;.writelines(lines) 将一个元素全为字符串的列表写入文件，&gt;&gt;&gt;ls=[“中国”, “法国”, “美国”]&gt;&gt;&gt;f.writelines(ls)&gt;&gt;&gt;中国法国美国 &lt;变量名&gt;.seek(offset) 改变当前文件操作指针的位置，offset含义如下：0-文件开头，1-当前位置，2-文件结尾 代码示例： 12345678910fo = open(\"output.txt\", \"w+\")sl = [\"中国\", \"法国\", \"美国\"]fo.writelines(ls)fo.seek(0) #写完之后将文件指针移到文件开头，再进行遍历输出for line in fo: print(line)fo.close()运行效果：中国法国美国 7.2 实例：自动轨迹绘制代码如下： 12345678910111213141516171819202122#AutoTraceDraw.pyimport turtle as tt.title('自动轨迹绘制')t.setup(800, 600, 0, 0)t.pencolor(\"red\")t.pensize(5)#数据读取datals = []f = open(\"data.txt\")for line in f: line = line.replace(\"\\n\", \" \") if line != \" \": #eval内参数为空时报错EOF，需加if判断 datals.append(list(map(eval, line.split(\",\"))))f.close()#自动绘制for i in range(len(datals)): t.pencolor(datals[i][3], datals[i][4], datals[i][5]) t.fd(datals[i][0]) if datals[i][1]: t.right(datals[i][2]) else: t.left(datals[i][2]) 程序line13datals.append(list(map(eval, line.split(\",\"))))中的eval函数内参数为空时报错，需要加入if判断，eval()语法为：eval(expression[, globals[, locals]])。expression参数不为空。 7.3 一维数据的格式化处理 数据组织的维度 一维数据：由对等关系的有序或无序数据构成，采用线性方式组织，对应列表、数组和集合等概念。二维数据：由多个一维数据构成，是一维数据的组合形式，表格是典型的二维数据。多维数据：由一维或二维数据在新维度上扩展形成。 一维数据的表示：列表（有序）或集合（无序）。 一维数据的存储:空格分隔、逗号分隔、特殊符号分隔。 一维数据的处理：字符串方法.split()和.join()。 7.4 二维数据的格式化处理 二维数据的表示：二维列表，每个列表元素又是一个列表。 CSV数据存储格式：由逗号分隔值的一种存储方式，每行一个一维数据，采用逗号分隔，无空行。 二维数据的处理：for循环+.split()和.join()。 7.5 wordcloud库的使用 wordcloud库是优秀的词云展示第三方库,词云是以词语为基本单位，更加直观和艺术的展示文本。 安装wordcloud库：：Windows环境下打开cmd命令行，输入pip install wordcloud命令，安装之后会提示Successfully installed即安装完成。安装过程中出现问题，在这个网站https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted下载库文件`wordcloud-1.7.0-cp37-cp37m-win_amd64.whl`，存放在库文件夹中，在该文件夹中执行命令`pip install wordcloud-1.7.0-cp37-cp37m-win_amd64.whl`即可。 wordcloud库的使用： 1.wordcloud.WordCloud()代表一个文本对应的词云2.可以根据文本中词语出现的频率等绘制词云3.绘制词云的形状、尺寸和颜色都可以设定 wordcloud库常规方法 方法 描述 w.generate(txt) 向WordCloud对象w中加载文本txt，&gt;&gt;&gt;w.generate(“Python and WordCloud”) w.to_file(filename) 将词云输出为图像文件，.png或.jpg格式，&gt;&gt;&gt;w.to_file(“outfile.png”) 配置对象参数w = wordcloud.WordCloud(&lt;参数&gt;) 参数 描述 width 指定词云对象生成图片的宽度，默认400像素，&gt;&gt;&gt;w=wordcloud.WordCloud(width=600) height 指定词云对象生成图片的高度，默认200像素，&gt;&gt;&gt;w=wordcloud.WordCloud(height=400) min_font_size 指定词云中字体的最小字号，默认4号，&gt;&gt;&gt;w=wordcloud.WordCloud(min_font_size=10) max_font_size 指定词云中字体的最大字号，根据高度自动调节，&gt;&gt;&gt;w=wordcloud.WordCloud(min_font_size=20) font_step 指定词云中字体字号的步进间隔，默认为1，&gt;&gt;&gt;w=wordcloud.WordCloud(font_step=2) font_path 指定字体文件的路径，默认None，&gt;&gt;&gt;w=wordcloud.WordCloud(font_path=”msyh.ttc”) max_words 指定词云显示的最大单词数量，默认200，&gt;&gt;&gt;w=wordcloud.WordCloud(max_words=20) stop_words 指定词云的排除词列表，即不显示的单词列表，&gt;&gt;&gt;w=wordcloud.WordCloud(stop_words=”Python”) mask 指定词云形状，默认为长方形，需要引用imread()函数，&gt;&gt;&gt;from scipy.misc import imread&gt;&gt;&gt;mk=imread(“pic.png”)&gt;&gt;&gt;w=wordcloud.WordCloud(mask=mk) background_color 指定词云图片的背景颜色，默认为黑色，&gt;&gt;&gt;w=wordcloud.WordCloud(background_color=”White”) 示例如下： 123456789101112131415161.一段英文生成词云import wordcloudtxt = \"life is short, you need python\"w = wordcloud.WordCloud(background_color=\"white\")w.generate(txt)w.to_file(\"ciyun1.png\")2.一段中文生成词云import wordcloudimport jiebatxt = \"购买自住住房申请住房公积金贷款的，不受缴存时间限制，按缴纳基数计算可贷额度，贷款额度可放宽至最高额度的2倍。\"w = wordcloud.WordCloud(width=1000, font_path=\"Alibaba-PuHuiTi-Medium.ttf\", height=700)w.generate(\" \".join(jieba.lcut(txt)))w.to_file(\"ciyun2.png\")显示中文的字体文件的路径需要 font_path=\"xxx\" 表示出来，或者直接将字体文件放在程序工程文件夹下，最后生成的词云图才会显示汉字。 7.6 实例：读取文件生成词云123456789101112131415161718192021222324252627282930311.读取 suzhou.txt 文件生成词云import wordcloudimport jiebaf = open(\"suzhou.txt\", \"r\", encoding=\"utf-8\")t = f.read()f.close()ls = jieba.lcut(t)txt = \" \".join(ls)w = wordcloud.WordCloud(font_path=\"Alibaba-PuHuiTi-Medium.ttf\", width=1000, height=700, background_color=\"white\")#生成的词云图中最多显示15个词语，通过 max_words=xx 设置#w = wordcloud.WordCloud(font_path=\"Alibaba-PuHuiTi-Medium.ttf\", width=1000, height=700, background_color=\"white\", max_words=15)w.generate(txt)w.to_file(\"suzhou_ciyun.png\")2.1.读取 suzhou.txt 文件生成词云，并生成特定形状import wordcloudimport jiebafrom scipy.misc import imreadmask = imread(\"star.png\")f = open(\"suzhou.txt\", \"r\", encoding=\"utf-8\")t = f.read()f.close()ls = jieba.lcut(t)txt = \" \".join(ls)w = wordcloud.WordCloud(font_path=\"Alibaba-PuHuiTi-Medium.ttf\", mask=mask, width=1000, height=700, background_color=\"white\")#生成的词云图中最多显示15个词语，通过 max_words=xx 设置#w = wordcloud.WordCloud(font_path=\"Alibaba-PuHuiTi-Medium.ttf\", width=1000, height=700, background_color=\"white\", max_words=15)w.generate(txt)w.to_file(\"pic_ciyun.png\")安装scipy库和imread库，直接执行命令 pip install xxx ,出问题就提前下好库文件在安装，安装好两个库仍然报错ImportError: cannot import name 'imread' from 'scipy.misc'，需要降低scipy库，执行命令 pip install scipy==1.2.0 问题解决，然后程序中选好特定图像文件，即可生成特定图像的词云。","categories":[],"tags":[]}],"categories":[],"tags":[]}