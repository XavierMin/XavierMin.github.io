{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://xaviermin.github.io","root":"/"},"pages":[],"posts":[{"title":"VS2017中部署OpenCV3.4.1","slug":"VS2017中部署OpenCV3.4.1","date":"2020-09-16T04:58:11.988Z","updated":"2020-09-16T04:57:19.552Z","comments":true,"path":"2020/09/16/VS2017中部署OpenCV3.4.1/","link":"","permalink":"http://xaviermin.github.io/2020/09/16/VS2017%E4%B8%AD%E9%83%A8%E7%BD%B2OpenCV3.4.1/","excerpt":"OpenCV简介OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的IPP进行加速处理。OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。简单理解OpenCV就是一个库，是一个SDK，一个开发包，解压后直接用就可以。","text":"OpenCV简介OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的IPP进行加速处理。OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。简单理解OpenCV就是一个库，是一个SDK，一个开发包，解压后直接用就可以。 1. 安装VS2017前面说了，OpenCV是一个SDK，得使用工具开发它，比如Visual Studio，网站教程比较多的是VS2017中部署OpenCV。 VS2017的安装此处省略，可以去官网下载，也可以网上搜安装包，推荐微信公众号：软件安装管家。 2. 下载并配置OpenCV2.1 下载在OpenCV官网下载你需要的版本，点击RELEASES（发布）。 下载后是个.exe文件，不像一般软件双击.exe文件进行安装，这个是双击进行解压（点击Extract），也可以理解为安装，实质就是解压一下，完了是个文件夹，放到你想放置的位置，打开文件夹是这样 其中build是OpenCV使用时要用到的一些库文件，而sources中则是OpenCV官方提供的一些demo示例源码。 2.2 配置把OpenCV文件夹放好地方后，依次选择计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量，找到Path变量，选中并点击编辑，然后新建把你的OpenCV执行文件的路径填进去，然后一路点确定，这样环境变量就配置完了。 3. VS2017中部署OpenCV打开VS2017，新建一个空项目。 右击源文件-&gt;添加-&gt;新建项 选择一个C++文件，点击添加 找到属性管理器，双击Debug|x64下的Microsoft.Cpp.x64.user，进行配置 对属性中的 VC++目录-&gt;包含目录和VC++目录-&gt;库目录进行添加相关路径，根据自己存放OpenCV的路径添加 包含目录中加入 G:\\OpenCV\\opencv\\build\\include G:\\OpenCV\\opencv\\build\\include\\opencv G:\\OpenCV\\opencv\\build\\include\\opencv2 库目录中加入 G:\\OpenCV\\opencv\\build\\x64\\vc15\\lib 在链接器-&gt;输入-&gt;附加依赖项中加入opencv_world341d.lib 再接着，在链接器-&gt;常规-&gt;附加库目录添加G:\\OpenCV\\opencv\\build\\x64\\vc15\\lib 最后解决方案平台一栏换成X64 下面进行测试，在刚才新建的工程文件目录下，添加一张.jpg格式的图片 回到工程添加的C++文件中，输入代码 12345678#include&lt;opencv2/opencv.hpp&gt;using namespace cv;int main()&#123; Mat img = imread(\"1.jpg\"); //读入一张图片 imshow(\"显示图片成功\", img); //在窗口中显示图片 waitKey(30000); //等待30000ms(30s)后窗口自动关闭 &#125; 点击本地调试 图片显示成功，运行30s自动退出。 以上，配置完成！","categories":[],"tags":[]},{"title":"ESP8266连接阿里云","slug":"ESP8266连接阿里云","date":"2020-09-09T08:02:55.506Z","updated":"2020-09-09T08:17:38.562Z","comments":true,"path":"2020/09/09/ESP8266连接阿里云/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/ESP8266%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91/","excerpt":"基于Arduino平台用ESP8266接入阿里云前面在零基础快速学习Android开发的两篇博客里介绍了基于EMQ搭建自己的MQTT服务器，是免费使用的，而想使用阿里云的MQTT服务器应该是要购买阿里云的云服务，才能使用阿里云物联网管理平台，目前因为是学生，加上今年上半年疫情原因，阿里云针对学生开放免费半年的使用期限，可能我知道的比较晚，申请完只有两个月免费使用，但了解了解阿里云也足够了，具体操作可以搜B站视频，阿里云白嫖一年免费服务器？学生党专属福利！阿里云在家实践活动。","text":"基于Arduino平台用ESP8266接入阿里云前面在零基础快速学习Android开发的两篇博客里介绍了基于EMQ搭建自己的MQTT服务器，是免费使用的，而想使用阿里云的MQTT服务器应该是要购买阿里云的云服务，才能使用阿里云物联网管理平台，目前因为是学生，加上今年上半年疫情原因，阿里云针对学生开放免费半年的使用期限，可能我知道的比较晚，申请完只有两个月免费使用，但了解了解阿里云也足够了，具体操作可以搜B站视频，阿里云白嫖一年免费服务器？学生党专属福利！阿里云在家实践活动。 1.ESP8266 Arduino开发环境的搭建1.1 下载Arduino官网链接：Download the Arduino IDE 1.2 安装Arduino安装步骤参考百度，教程一搜一大把… 1.3 配置ESP8266环境在Arduino中针对ESP8266的基本配置这里不多做介绍，主要介绍ESP8266接入阿里云需要哪些东西。 1.3.1 安装PubSubClient库打开工具-&gt;管理库，搜索PubSubClient，安装最新版本即可。 1.3.2 安装ArduinoJson库打开工具-&gt;管理库，搜索ArduinoJson，安装 5 版本，选择任意一个均可。 1.3.3 安装Crypto库打开工具-&gt;管理库，搜索Crypto，安装最新版本即可。这是个加密函数库，里面包含了SHA256.h，是加密功能的头文件。 2.阿里云物联网平台的配置进入阿里云物联网平台官网，点击控制台-&gt;物联网管理平台。 点击设备管理-&gt;产品-&gt;创建产品，创建一个控制ESP8266开发板上LED灯的产品。 点击设备管理-&gt;设备-&gt;添加设备，设备所属产品选择上一步创建的产品，给设备取合适的名字和备注，添加完成后在设备列表中显示有刚才添加的设备，但状态/启用状态为未激活状态。 下面进行ESP8266程序的配置。 3.ESP8266程序配置3.1 修改WIFI名称和密码将程序中WIFI_SSID、WIFI_PASSWD的宏定义改成自己的WIFI。 12#define WIFI_SSID \"TP-LINK_531\"#define WIFI_PASSWD \"zhoulianying531\" 3.2 修改设备信息将程序中PRODUCT_KEY、DEVICE_NAME、DEVICE_SECRET的宏定义改成想要链接的设备信息，这里改成上述步骤创建的设备信息。 123#define PRODUCT_KEY \"a1qBJBdexnM\" //替换自己的PRODUCT_KEY#define DEVICE_NAME \"LED_control\" //替换自己的DEVICE_NAME#define DEVICE_SECRET \"b3a3fa8711aa2cd1e7ea21f34336e55d\"//替换自己的DEVICE_SECRET 点击设备后面的操作-&gt;查看，即可看到需要的设备信息。 至此，需要配置的地方全部完成。 上述信息修改完成后，上传到ESP8266开发板上，打开Arduino的串口监视器，即可看到ESP82666上传到阿里云的信息。 回到阿里云物联网平台，即可看到刚创建的设备状态显示为在线。 点击监控运维-&gt;在线调试可对设备进行远程控制，此处可以控制ESP8266上面LED灯的亮灭。 设备正常运行，阿里云连接成功！！！","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（八）","slug":"RISC-V on T-Core系列课程（八）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-15T06:09:00.532Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（八）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/","excerpt":"第八讲——RISC-V on T-Core的开发流程本讲从RISC-V on T-Core的框架出发， 系统介绍了RISC-V CPU 在T-Core上的实现及其嵌入式设计的流程。此外，在简单介绍TRRV-E-SDK包后，step by step地搭建RISC-V on T-Core的开发环境，并且对T-Core RISC-V 硬件开发流程和应用程序开发流程进行了鞭辟入里的解析：包括如何运用Quartus Prime工具及eclipse软件来进行实操，以及如何使用makefile文件一键编译、一键下载应用程序到T-Core开发板等。","text":"第八讲——RISC-V on T-Core的开发流程本讲从RISC-V on T-Core的框架出发， 系统介绍了RISC-V CPU 在T-Core上的实现及其嵌入式设计的流程。此外，在简单介绍TRRV-E-SDK包后，step by step地搭建RISC-V on T-Core的开发环境，并且对T-Core RISC-V 硬件开发流程和应用程序开发流程进行了鞭辟入里的解析：包括如何运用Quartus Prime工具及eclipse软件来进行实操，以及如何使用makefile文件一键编译、一键下载应用程序到T-Core开发板等。 1. RISC-V on T-Core的框架整体框架 T-Core开发板下载链路选择 2. TRRV-E-SDK简介TRRV-E-SDK是友晶科技基于开源HBird-E-SDK平台修改的 TRRV-E-SDK基于HBird-E-SDK的主要修改： \\software：基于T-Core开发板外设的软件示例 \\work：基于GitHub的源码重新编译的工具链 添加blaster_6810.hex，用于make upload软件示例 基于T-Core开发板修改Makefile 3. RISC-V on T-Core开发环境的搭建开发环境 Linux环境下USB Blaster II驱动的安装 切换到/etc/udev/rules.d文件夹路径，使用touch命令创建51-usbblaster.rules文件 使用gedit命令打开51-usbblaster.rules文件，添加以下内容后保存： 12SUBSYSTEMS&#x3D;&#x3D;&quot;usb&quot;,ATTRS&#123;idVendor&#125;&#x3D;&#x3D;&quot;09fb&quot;,ATTRS&#123;idProduct&#125;&#x3D;&#x3D;&quot;6010&quot;,MODE&#x3D;&quot;0666&quot;SUBSYSTEMS&#x3D;&#x3D;&quot;usb&quot;,ATTRS&#123;idVendor&#125;&#x3D;&#x3D;&quot;09fb&quot;,ATTRS&#123;idProduct&#125;&#x3D;&#x3D;&quot;6810&quot;,MODE&#x3D;&quot;0666&quot; 下载好的E203开发包在Linux环境下解压缩 OpenJDK安装 OpenOCD安装 4. T-Core RISC-V硬件开发流程视频教程是基于Linux Quartus开发 创建TRRV Core工程 创建顶层.v文件 例化2个PLL 添加蜂鸟core源文件 管脚分配 编译生成.pof配置文件 烧写.pof文件到FPGA板子上（使用命令行烧写.pof文件） 5. T-Core RISC-V应用程序开发流程 启动Eclipse创建blinking_LED1工程 设置blinking_LED1工程工程BSP 设置工具链 设置编译和链接选项 设置工程的包含路径和文件 编译并运行blinking_LED1工程 调试blinking_LED1工程 RISC-V工具链 Makefile详解 编译应用程序 下载二进制文件","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（九）","slug":"RISC-V on T-Core系列课程（九）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-16T01:23:37.627Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（九）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89/","excerpt":"第九讲——RISC-V实战演练之GPIO与UART本讲将从以下三个方面展开：其一，将系统介绍 RISC-V on T-Core 的 GPIO 特性，以及如何实现GPIO读写控制；其二，将对软件上如何对中断进行仲裁及处理的机制进行深入讲解；其三，将详细阐述包含printf函数的移植实现在内的UART通讯。","text":"第九讲——RISC-V实战演练之GPIO与UART本讲将从以下三个方面展开：其一，将系统介绍 RISC-V on T-Core 的 GPIO 特性，以及如何实现GPIO读写控制；其二，将对软件上如何对中断进行仲裁及处理的机制进行深入讲解；其三，将详细阐述包含printf函数的移植实现在内的UART通讯。 1. 实战之GPIO读写E203外设概览 外设地址分配 实验一：GPIO读写 GPIO读写流程 2. 实战之GPIO中断外部中断 GPIO外部中断 外部中断设置步骤 中断处理机制 中断相关寄存器 实验二：GPIO中断 程序流程图 3. 实战之串口UARTUART串口控制器 UART寄存器定义 UART波特率配置 实验三：串口通讯 UART收发实现流程","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（十）","slug":"RISC-V on T-Core系列课程（十）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-16T01:24:40.013Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（十）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89/","excerpt":"第十讲——RISC-V实战演练之定时器、PWM、I2C、SPI本讲从以下四个方面展开：其一，系统介绍了 RISC-V on T-Core 上的定时器，并详细讲述了如何实现定时的功能；其二，介绍了如何使用 PWM 来进行控制；其三，详细阐述了如何使用 I2C 控制器对 SIF-TMD 子卡上的 I2C 设备实现读写操作。最后，还介绍了如何使用 SPI 控制器与 SIF-TMD 上的 SPI 设备进行通信。","text":"第十讲——RISC-V实战演练之定时器、PWM、I2C、SPI本讲从以下四个方面展开：其一，系统介绍了 RISC-V on T-Core 上的定时器，并详细讲述了如何实现定时的功能；其二，介绍了如何使用 PWM 来进行控制；其三，详细阐述了如何使用 I2C 控制器对 SIF-TMD 子卡上的 I2C 设备实现读写操作。最后，还介绍了如何使用 SPI 控制器与 SIF-TMD 上的 SPI 设备进行通信。 1. RISC-V on T-Core的框架整体框架","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（十一）","slug":"RISC-V on T-Core系列课程（十一）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-15T06:26:29.773Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（十一）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/","excerpt":"第十一讲——RISC-V实战演练之自定义指令本讲介绍了自定义指令的软件实现流程，包含指令操作码的定义生成、GNU toochain的修改验证、C代码内联汇编方式调用自定义指令等。该讲还详细阐述了RISC-V on T-Core自定义指令实现流程的每一个步骤，并设计有一个矩阵乘法的demo，以实现和验证dot自定义指令对运算时间、周期和指令数、CPI值等的提升。","text":"第十一讲——RISC-V实战演练之自定义指令本讲介绍了自定义指令的软件实现流程，包含指令操作码的定义生成、GNU toochain的修改验证、C代码内联汇编方式调用自定义指令等。该讲还详细阐述了RISC-V on T-Core自定义指令实现流程的每一个步骤，并设计有一个矩阵乘法的demo，以实现和验证dot自定义指令对运算时间、周期和指令数、CPI值等的提升。 1. RISC-V on T-Core的框架整体框架","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（十二）","slug":"RISC-V on T-Core系列课程（十二）","date":"2020-09-09T07:54:01.295Z","updated":"2020-09-15T06:27:39.356Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（十二）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/","excerpt":"第十二讲——RISC-V实战演练之FreeRTOS在这一讲中，首先介绍了常见的操作系统及 FreeRTOS 系统特性；然后，着重介绍了FreeRTOS 的工作原理，包括任务管理，内存管理，任务间通信的队列，信号量，互斥量，以及中断管理，软件定时器，临界区和挂起调度器等；最后，通过一个实例，介绍了将 FreeRTOS 移植到 RISC-V 的关键内容和创建 FreeRTOS 工程中进行工程配置的注意事项，并通过具体代码对 FreeRTOS 实时任务调度原理进行了讲解。","text":"第十二讲——RISC-V实战演练之FreeRTOS在这一讲中，首先介绍了常见的操作系统及 FreeRTOS 系统特性；然后，着重介绍了FreeRTOS 的工作原理，包括任务管理，内存管理，任务间通信的队列，信号量，互斥量，以及中断管理，软件定时器，临界区和挂起调度器等；最后，通过一个实例，介绍了将 FreeRTOS 移植到 RISC-V 的关键内容和创建 FreeRTOS 工程中进行工程配置的注意事项，并通过具体代码对 FreeRTOS 实时任务调度原理进行了讲解。 1. RISC-V on T-Core的框架整体框架","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（七）","slug":"RISC-V on T-Core系列课程（七）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:12:02.367Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（七）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"第七讲——RISC-V处理器的可扩展性设计及实现本讲主要介绍 了RISC-V 处理器的可扩展性设计与实现。首先，从指令集出发，分析 了RISC-V 处理器可扩展性的体现；然后，着重介绍了 RISC-V 自定义指令的流程，并详细分析了自定义指令时对 RISC-V 处理器硬件的修改；最后，介绍了如何在 RISC-V on T-Core 上实现一个自定义的 DOT 指令的代码。","text":"第七讲——RISC-V处理器的可扩展性设计及实现本讲主要介绍 了RISC-V 处理器的可扩展性设计与实现。首先，从指令集出发，分析 了RISC-V 处理器可扩展性的体现；然后，着重介绍了 RISC-V 自定义指令的流程，并详细分析了自定义指令时对 RISC-V 处理器硬件的修改；最后，介绍了如何在 RISC-V on T-Core 上实现一个自定义的 DOT 指令的代码。 1. RISC-V架构的可扩展性 RISC-V指令集的扩展 指令编码空间的扩展 2. RISC-V自定义指令的基本流程RISC自定义指令 组合逻辑型自定义指令 多周期型自定义指令 RISC-V自定义指令流程 3. RISC-V on T-Core自定义指令设计实现自定义指令——dot指令 dot指令格式选择 CPU硬件修改流程","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（三）","slug":"RISC-V on T-Core系列课程（三）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:51.149Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（三）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"第三讲——RISC-V处理器单指令周期设计与实现本讲主要介绍单指令周期 CPU 的设计与实现。根据指令周期的五个执行步骤：取指、译码、执行、访存、写回，分别设计 RISC-V 六种类型指令的数据通路和控制器。此外，还介绍了 T-Core 开发板上实现 RISC-V 处理器的指令周期所涉及到的五个步骤的代码。","text":"第三讲——RISC-V处理器单指令周期设计与实现本讲主要介绍单指令周期 CPU 的设计与实现。根据指令周期的五个执行步骤：取指、译码、执行、访存、写回，分别设计 RISC-V 六种类型指令的数据通路和控制器。此外，还介绍了 T-Core 开发板上实现 RISC-V 处理器的指令周期所涉及到的五个步骤的代码。 1. 单指令周期CPU概述 指令周期：CPU取出并执行一条指令所需的全部时间。指令执行包括五个步骤——取指（Instruction Fetch）、译码（Instruction Decode）、执行（Execute）、访存（Memory Access）、写回（Write Back）。 CPU周期：也称为机器周期，一个机器周期由若干个时钟周期组成。 CPI（Clock Cycle Per Instruction）：执行每条指令所需的时钟周期数的平均值。 单指令周期CPU：全部指令选用一个CPU周期完成的系统。 2. 单指令周期CPU数据通路的设计需要使用的部件 寄存器堆 3. 单指令周期CPU控制器的设计I-Type指令的控制信号 控制信号的产生 把数据通路和控制器组合在一起，就得到了单指令周期CPU 4. RISC-V on T-Core单指令周期代码解析BIU是系统总线 IFU - 取指、简单译码、分支预测 EXU - 译码、派遣、执行、交付、写回 LSU - 访存","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（六）","slug":"RISC-V on T-Core系列课程（六）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:05.303Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（六）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"第六讲——RISC-V处理器中断与异常处理机制及实现本讲主要介绍了CPU中断与异常的概念，包括中断与异常的屏蔽、等待、套嵌和优先级等。此外，还详细介绍了中断与异常相关的寄存器，以及单指令周期数据通路中断与异常的控制机制和流水线中断与异常的控制机制。同样，在最后还对RISC-V on T-Core流水线的中断与异常控制代码进行了解析。","text":"第六讲——RISC-V处理器中断与异常处理机制及实现本讲主要介绍了CPU中断与异常的概念，包括中断与异常的屏蔽、等待、套嵌和优先级等。此外，还详细介绍了中断与异常相关的寄存器，以及单指令周期数据通路中断与异常的控制机制和流水线中断与异常的控制机制。同样，在最后还对RISC-V on T-Core流水线的中断与异常控制代码进行了解析。 1. 中断与异常的处理机制异常（Exception）：内部同步异常，出现在CPU内部，例如存储非法访问，未定义指令，系统调用… 中断（Interrupt）：外部异步中断，来自CPPU内部，例如GPIO，串口，定时器… 中断和异常的处理过程 中断和异常的相关寄存器（CSR） 寄存器具体意义 查询中断 向量中断 中断和异常的退出过程 中断返回 中断屏蔽和中断等待 中断优先级 2. 带中断和异常处理功能的CPU的设计与实现单指令周期CPU中 五级流水线中 3. RISC-V on T-Core的中断与异常代码解析E203二级流水线数据通路","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（五）","slug":"RISC-V on T-Core系列课程（五）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:15.827Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（五）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"第五讲——RISC-V处理器存储器层次化结构设计与实现本讲主要介绍了存储器的层次化结构。首先，从局部性原理出发，构建存储器的层次化结构；然后着重分析了Cache 的原理与改进方法、虚拟存储器的管理两大方面，比如 Cache 的三种映射机制、数据的一致性问题、虚拟存储器的两种管理方法以及 TLB 的 Verilog 实现等；最后对 RISC-V on T-Core 的存储器系统的代码进行了讲解。","text":"第五讲——RISC-V处理器存储器层次化结构设计与实现本讲主要介绍了存储器的层次化结构。首先，从局部性原理出发，构建存储器的层次化结构；然后着重分析了Cache 的原理与改进方法、虚拟存储器的管理两大方面，比如 Cache 的三种映射机制、数据的一致性问题、虚拟存储器的两种管理方法以及 TLB 的 Verilog 实现等；最后对 RISC-V on T-Core 的存储器系统的代码进行了讲解。 1. 存储器层次化结构概述计算机的主要三大件：CPU、存储器、IO设备。 速度比较快的存储器靠近处理器，速度比较慢的离处理器比较远。存储器的层次化结构主要由两个层次：缓存和主存、主存和辅存。 缓存和主存：主要解决CPU和主存速度不匹配的问题，缓存速度比主存速度快很多。 主存和辅存：主要解决村相互系统流量的问题。 SRAM和DRAM 2. Cache的原理与改进Cache的结构 详细讲解参考博客：存储层次结构（二） 3. 虚拟存储器管理及TLB设计虚拟存储器 虚拟存储器的管理 分段管理 分页管理 RISC-V存储器相关的指令 4. RISC-V on T-Core的存储器系统代码解析E203 CPU存储器框图 TCM=Tightly Coupled Memory，是一种高速缓存，据说是被直接集成在CPU芯片中。DS有两种TCM，分别是ITCM（Instruction TCM）和DTCM（Data TCM）。 ITCM&amp;DTCM：ITCM是cortex内核中指令传输总线，DTCM是cortex内核中数据传输总线是cpu内核同flash及sram之间传输指令和数据的通道，指令的取指和执行及数据的读写在性能及管理上存在差异性。","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（四）","slug":"RISC-V on T-Core系列课程（四）","date":"2020-09-09T07:52:30.271Z","updated":"2020-09-14T03:08:41.390Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（四）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"第四讲——RISC-V处理器流水线设计及实现本讲系统介绍了处理器流水线的概念与结构，并对流水线与单指令周期进行了比较分析。此外，探讨了流水线设计带来的冒险，诸如结构冒险、数据冒险、控制冒险等，及其解决方法。最后，对RISC-V on T-Core流水线实现的代码进行了解析。博客参考：课程——计算机组成与设计","text":"第四讲——RISC-V处理器流水线设计及实现本讲系统介绍了处理器流水线的概念与结构，并对流水线与单指令周期进行了比较分析。此外，探讨了流水线设计带来的冒险，诸如结构冒险、数据冒险、控制冒险等，及其解决方法。最后，对RISC-V on T-Core流水线实现的代码进行了解析。博客参考：课程——计算机组成与设计 1. 处理器流水线概念与结构在单指令周期CPU中，所有指令的指令周期是等长的，指令周期的长短取决于指令周期最长的一条，以此确保每条指令在一个周期内都能完成，所以在单指令周期CPU中处理器在一个指令周期中经常会处在等待的状态。 提高处理器的性能，采用流水线技术 单指令周期与流水线的比较 处理器性能评估“铁律”：程序执行时间=程序指令数目 x 指令周期数CPI x 时钟周期 单指令周期CPU的CPI是1，流水线CPI约等于1（大于1） 流水线阶段划分 为了确保硬件共享的同时，前面的指令数据不被丢失，需要增加阶段寄存器来保存中间的值可控制信号。这些增加的寄存器称为流水线寄存器。 2. 处理器流水线的冒险与解决流水线技术之所以能提高性能 究其本质是利用了时间上的并行性，那它让原本应该先后执行的指令在时间上一定程度的并行起来，然而这也会带来一些冲突和矛盾，进而可能引发错误。 冒险（Hazard）：在流水线中我们希望当前每个时钟周期都有一条指令进入流水线可以执行。但在某些情况下，下一条指令无法按照预期开始执行，这种情况就被称为冒险。 冒险分为三种： 结构冒险：如果一条指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务，那就导致了结构冒险。（这里结构是指硬件当中的某个部件） 数据冒险：如果一条指令需要某数据而该数据正在被之前的指令操作，那这条指令就无法执行，就导致了数据冒险。 控制冒险：如果现在要执行哪条指令，是由之前指令的运行结果决定，而现在那条之前指令的结果还没产生，就导致了控制冒险。 结构冒险解决方法： 指令之间轮流使用硬件，此时会有一些指令需要被阻塞。 在设计中添加更多的硬件以满足需求。 寄存器文件结构冒险 流水线的数据冒险分类 阻塞（插入气泡）会降低CPU性能，即增大CPI值 流水线的控制冒险 3. RISC-V on T-Core流水线代码解析E203流水线数据通路","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（二）","slug":"RISC-V on T-Core系列课程（二）","date":"2020-09-09T07:51:55.782Z","updated":"2020-09-14T03:09:03.155Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（二）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"第二讲——RISC-V处理器ALU设计与实现本讲主要介绍了数据通路部件中的核心——ALU（Arithmetic and Logic Unit，算术逻辑运算单元）。从 RISC-V 指令集出发，着重分析 RISC-V 六种类型的指令。接着，从1位 ALU 的设计实现开始，由易到难，演示通过逐步添加运算单元，并将其进行扩展等操作，使之最后形成一个功能完善的、32位 RISC-V ALU。最后，将介绍在T-Core 开发板上实现 RISC-V ALU 所需的 Verilog HDL 代码，结合 ALU 设计实现的理论知识，从 ALU 的整体框架入手，逐一分析每个模块所涉及的控制信号和运算。","text":"第二讲——RISC-V处理器ALU设计与实现本讲主要介绍了数据通路部件中的核心——ALU（Arithmetic and Logic Unit，算术逻辑运算单元）。从 RISC-V 指令集出发，着重分析 RISC-V 六种类型的指令。接着，从1位 ALU 的设计实现开始，由易到难，演示通过逐步添加运算单元，并将其进行扩展等操作，使之最后形成一个功能完善的、32位 RISC-V ALU。最后，将介绍在T-Core 开发板上实现 RISC-V ALU 所需的 Verilog HDL 代码，结合 ALU 设计实现的理论知识，从 ALU 的整体框架入手，逐一分析每个模块所涉及的控制信号和运算。 1. ALU概述ALU是什么 数据通路 2. RISC-V指令集和ALU的联系RISC-V指令集类型（六种） R-type指令与ALU I-type指令与ALU Load/Store指令与ALU B-type指令与ALU Jump指令与ALU U-type指令与ALU 总结：RISC-V指令涉及到的运算： R-type/I-type：加法、减法、与、或、异或、比较大小、逻辑移位、算术移位 B-type：比较相等、比较大小 U-type：左移、加法 S-type：加法 J-type：加法 RISC-V ALU基本功能： 算术运算：加法、减法 逻辑运算：与、或、异或 其他运算：移位、比较 将多种算术和逻辑组合到一个单元内 3. RISC-V ALU的设计与实现ALU的设计：1位扩展到32位 1位ALU的实现 32位ALU的实现 ALU减法运算实现 ALU比较运算实现 RISC-V乘法器实现 RISC-V除法器实现 4. RISC-V on T-Core ALU代码解析ALU的子模块的运算请求","categories":[],"tags":[]},{"title":"RISC-V on T-Core系列课程（一）","slug":"RISC-V on T-Core系列课程（一）","date":"2020-09-09T07:17:04.044Z","updated":"2020-09-14T03:09:21.865Z","comments":true,"path":"2020/09/09/RISC-V on T-Core系列课程（一）/","link":"","permalink":"http://xaviermin.github.io/2020/09/09/RISC-V%20on%20T-Core%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"第一讲——RISC-V架构处理器基础RISC-V（发音为“risk-five”）是一个基于精简指令集（RISC）原则的开源指令集架构（ISA）。与大多数指令集相比，RISC-V指令集可以自由地用于任何目的，允许任何人设计、制造和销售RISC-V芯片和软件。虽然这不是第一个开源指令集，但它具有重要意义，因为其设计使其适用于现代计算设备（如仓库规模云计算机、高端移动电话和微小嵌入式系统）。设计者考虑到了这些用途中的性能与功率效率。该指令集还具有众多支持的软件，这解决了新指令集通常的弱点。","text":"第一讲——RISC-V架构处理器基础RISC-V（发音为“risk-five”）是一个基于精简指令集（RISC）原则的开源指令集架构（ISA）。与大多数指令集相比，RISC-V指令集可以自由地用于任何目的，允许任何人设计、制造和销售RISC-V芯片和软件。虽然这不是第一个开源指令集，但它具有重要意义，因为其设计使其适用于现代计算设备（如仓库规模云计算机、高端移动电话和微小嵌入式系统）。设计者考虑到了这些用途中的性能与功率效率。该指令集还具有众多支持的软件，这解决了新指令集通常的弱点。 1. 计算机体系结构整体结构图 处理器关键技术 存储器结构与内存访问 2. 指令集架构（ISA）知乎上一篇通俗易懂的讲解科普ISA、CPU架构原理。 ISA位于软件和硬件之间的接口，一套标准的规范，不具备实体，以文档的形式发布。 3. RISC-V指令架构RISC-V诞生于2010年，有如下特点： 指令集完全开源免费（规范） 指令书目简洁 模块化的指令集 可扩展定制指令 完整工具链 有大量的开源实现和流片案例 RISC-V模块化的指令集 RISC-V统一的指令编码 RISC-V R（Register）型指令 RISC-V I（Immediate）型指令 RISC-V S（Store）型B（Branch）型指令，B是S的变体 RISC-V U（Upper immediate）型 J（ Jump）型指令，J是U的变体 RISC-V通用寄存器组 CSR（控制状态）寄存器组：用于记录运行状态，处理器内部寄存器 RISC-V的存储访问 RISC-V的寻址方式 RISC-V的中断 RISC-V的中断处理机制：响应中断和退出中断。 RISC-V支持机器模式、监督模式、用户模式 4. RISC-V on T-CoreT-Core开发板简介 RISC-V在Intel FPGA上实现 蜂鸟E203 MCU SoC RISC-V on T-Core的开发流程 总结介绍计算机系统的结构和处理器关键技术，结合ISA的定义对RISC-V指令集架构的讲解，包括RISC-V指令集的编码、寄存器组、存储访问、寻址访问、中断处理机制，简要 介绍RISC-V在T-Core上的实现。","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（五）","slug":"零基础快速学习Android开发（五）","date":"2020-09-05T05:10:25.549Z","updated":"2020-09-05T07:09:37.174Z","comments":true,"path":"2020/09/05/零基础快速学习Android开发（五）/","link":"","permalink":"http://xaviermin.github.io/2020/09/05/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"MQTT服务器的搭建——基于EMQ平台（Windows）前面一篇博客介绍了在Linux系统上基于EMQ平台搭建了MQTT服务器，这两天在测试连接过程中遇到问题，主要还是笔记本不行…开虚拟机太太太卡了，索性放弃，重新在台式机Windows系统上搭建MQTT服务器，成功之后发现也挺好用，测试啥的都很方便。下面直接介绍安装和测试过程，对EMQ、MQTT不做介绍。","text":"MQTT服务器的搭建——基于EMQ平台（Windows）前面一篇博客介绍了在Linux系统上基于EMQ平台搭建了MQTT服务器，这两天在测试连接过程中遇到问题，主要还是笔记本不行…开虚拟机太太太卡了，索性放弃，重新在台式机Windows系统上搭建MQTT服务器，成功之后发现也挺好用，测试啥的都很方便。下面直接介绍安装和测试过程，对EMQ、MQTT不做介绍。 EMQ官网：https://www.emqx.io/cn 官方介绍文档：https://docs.emqx.net/broker/v3/cn/install.html 登录官网可下载EMQ X安装包 官方介绍文档里有针对各种系统的安装步骤，但不够详细，只参考这个进行安装可能会出现各种问题，所有有事儿还是得找百度~ 1.在Windows下安装EMQ X Broker1.1 下载EMQ X安装包同样，先下载安装包，上链接 -&gt; EMQ X Broker 打开下载链接后选择版本，例如我选择目前的最新版v4.1.4，选择Windows/Windows/x86_64/zip。 下载完成进行解压，我直接解压到E盘，软件包里即包含如下文件，注意EMQ的存放路径不能有中文和空格。 1.2 安装EMQ X Broker使用管理员身份运行cmd命令窗口，跳转到emqx的存放路径下的/bin文件夹路径。 输入命令emqx install，安装emq。 输入命令emqx start，启动emq，若路径跳转到/emqx文件夹下，表明启动成功，若后续继续使用命令行输入，还需要跳转到/bin目录下。 然后可以使用命令emqx_ctl status查看emqx的状态。 如果要停止 EMQ X Broker，使用如下命令emqx stop，提示ok即停止。 1.3 验证完成以上步骤，EMQ应该已经成功启动，下面进行验证。 打开浏览器，输入http://localhost:18083 来查看 Dashboard，默认用户名是 admin，密码是 public。 能进入控制台，即表示EMQ安装成功！ 2.数据交互测试2.1 利用MQTTBox进行测试MQTTBox测试工具下载链接：http://workswithweb.com/mqttbox.html 使用MQTTBox工具测试MQTT服务器能否正常通信，自定义发布主题和订阅主题，安装完成后打开，点击主页的Creat MQTT Client创建一个MQTT客户端，信息填写如下图所示。 保存之后自动显示Connected，即连接成功，到控制台刷新可以看到刚创建的MQTT客户端信息。 MQTTBox连接上MQTT服务器后，进行订阅和发布主题。 2.2 控制台Websocket连接注意主机地址和端口需填写正确，主机地址为127.0.0.1，Websocket做MQTT连接时端口应该为8083。 2.3 订阅和发布消息测试连接成功后，订阅主题和发布消息进行测试，Websocket和MQTTBox一个发一个收，两两可以互相发送和接收消息，之前MQTTBox发布的主题为publish，订阅的主题为subscribe，所以Websocket这里就应该订阅MQTTBox发布的主题publish，向subscribe主题发送消息（即subscribe相当于Websocket的发布主题），设置如下： 在MQTTBox上发布一条消息hello world，然后在控制台的订阅消息列表可以看到刚才从MQTTBox发布的消息。 从Websocket发送一条消息How are you，然后再MQTTBox工具的订阅列表中可以看到。 MQTT服务器能正常发布、订阅消息，即在Windows上搭建成功！！！","categories":[],"tags":[]},{"title":"解决VMware打开报错的问题","slug":"解决VMware打开报错的问题","date":"2020-08-26T16:45:30.269Z","updated":"2020-08-26T17:19:38.837Z","comments":true,"path":"2020/08/27/解决VMware打开报错的问题/","link":"","permalink":"http://xaviermin.github.io/2020/08/27/%E8%A7%A3%E5%86%B3VMware%E6%89%93%E5%BC%80%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"VMware提示以独占方式锁定此配置文件失败。另一个正在运行的VMware进程可能正在使用配置文件前两天使用了VMware虚拟机，正常关闭后，今天再次打开虚拟机的时候提示异常“以独占方式锁定此配置文件失败”，查阅网上的说法，是之前虚拟机未被正常关机，有进程仍然在后台运行占用了配置文件，导致再次开启机器时提示异常。 下面是我在网上找的解决办法，亲测有用！！！","text":"VMware提示以独占方式锁定此配置文件失败。另一个正在运行的VMware进程可能正在使用配置文件前两天使用了VMware虚拟机，正常关闭后，今天再次打开虚拟机的时候提示异常“以独占方式锁定此配置文件失败”，查阅网上的说法，是之前虚拟机未被正常关机，有进程仍然在后台运行占用了配置文件，导致再次开启机器时提示异常。 下面是我在网上找的解决办法，亲测有用！！！ 通过禁用启动项的方式结束旧的进程占用 按“win +R”组合键，进入“运行”，输入msconfig，按回车键。 进入“系统配置”，选中“服务”，勾选左下角“隐藏所有Microsoft服务”，再打开“全部禁止”，打开“应用”。 再打开“服务”边上的“启动”选项，打开“点击任务管理器”。 在列出的启动项上，找到VMware Tray Process点击右键，选中“禁止”，禁止全部启动项。 关闭“任务管理器”，返回“系统配置”界面下打开“确定”，依据提示重启电脑。 电脑重启之后，再次按照上面流程启动所有服务和VMware Tray Process，VMware就可以正常启动了。","categories":[],"tags":[]},{"title":"ESP8266+BME280构建无线气象站","slug":"ESP8266+BME280构建无线气象站","date":"2020-08-25T07:04:31.567Z","updated":"2020-08-25T17:35:28.909Z","comments":true,"path":"2020/08/25/ESP8266+BME280构建无线气象站/","link":"","permalink":"http://xaviermin.github.io/2020/08/25/ESP8266+BME280%E6%9E%84%E5%BB%BA%E6%97%A0%E7%BA%BF%E6%B0%94%E8%B1%A1%E7%AB%99/","excerpt":"简介本案例是做一个简单的气象站，进行温度、湿度、压力、高度的测量。气压传感器模块有GY-68 BMP180 可以测大气压和温度，升级版是GY-BMP280，还有高配版BME280，可以多测一个湿度。 本案例展示了如何将BME280传感器模块与ESP8266一起使用，以使用Arduino IDE读取压力、温度、湿度、压力和估计高度。BME280传感器使用I2C或SPI通信协议与微控制器交换数据。","text":"简介本案例是做一个简单的气象站，进行温度、湿度、压力、高度的测量。气压传感器模块有GY-68 BMP180 可以测大气压和温度，升级版是GY-BMP280，还有高配版BME280，可以多测一个湿度。 本案例展示了如何将BME280传感器模块与ESP8266一起使用，以使用Arduino IDE读取压力、温度、湿度、压力和估计高度。BME280传感器使用I2C或SPI通信协议与微控制器交换数据。 1. 介绍1.1 BME280传感器BME280传感器使用I2C或SPI通信协议进行通信，我使用的是I2C通信协议进行通信，接线非常简单，使用默认的ESP8266 I2C引脚，如下表所示： BME280 ESP8266 VCC 3.3V GND GND SCL GPIO5 (D1) SDA GPIO4 (D2) 1.2 所需硬件 ESP8266开发板 x 1 BME280传感器模块 x 1 杜邦线 x 4 1.3 硬件接线图ESP8266与BME280传感器模块使用I2C通信。为此，将传感器连接到ESP8266 SDA 和 SCL 引脚，如下图所示。 2. 安装库文件该案例的ESP8266固件是使用Arduino IDE开发的。要从BME280传感器模块获取读数，需要安装Adafruit_BME280库。打开Arduino IDE并转到 工具 &gt;管理库，在搜索框中搜索adafruit bme280并安装该库。 还需要安装Adafruit_Sensor库。打开Arduino IDE并转到 工具 &gt;管理库，在搜索框中搜索Adafruit Unified Sensor并安装该库。 安装完成后，重新启动Arduino IDE。 3. 工程代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;Wire.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;Adafruit_Sensor.h&gt;#include &lt;Adafruit_BME280.h&gt;#include \"SSD1306.h\"#define SEALEVELPRESSURE_HPA (1013.25)Adafruit_BME280 bme; // I2CSSD1306 display(0x3c, D2, D1);// Replace with your network details//const char* ssid = \"Xiaomi_wifi\";//const char* password = \"18712183610\";const char* ssid = \"TP-LINK\";const char* password = \"20070529\";float h, t, p, pin;char temperatureFString[6];char humidityString[6];char pressureString[7];char pressureInchString[6];int count=0;// Web Server on port 80WiFiServer server(80);// only runs once on bootvoid setup() &#123; // Initializing serial port for debugging purposes Serial.begin(115200); delay(10); Wire.begin(D2, D1); Wire.setClock(100000); // Connecting to WiFi network Serial.println(); Serial.print(\"Connecting to \"); Serial.println(ssid); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(\".\"); &#125; Serial.println(\"\"); Serial.println(\"WiFi connected\"); // Starting the web server server.begin(); Serial.println(\"Web server running. Waiting for the ESP IP...\"); delay(10000); // Printing the ESP IP address Serial.println(WiFi.localIP()); Serial.println(F(\"BME280 test\")); bool status; status = bme.begin(0x76); if (!status) &#123;// if (!bme.begin()) &#123; Serial.println(\"Could not find a valid BME280 sensor, check wiring!\"); while (1); &#125; // Initialising the UI will init the display too. display.init(); display.flipScreenVertically(); display.setFont(ArialMT_Plain_16);&#125;void getWeather() &#123; h = bme.readHumidity(); t = bme.readTemperature(); //t = t*1.8+32; p = bme.readPressure()/100.0F; pin = 0.02953*p; dtostrf(t, 5, 1, temperatureFString); dtostrf(h, 5, 1, humidityString); dtostrf(p, 6, 1, pressureString); dtostrf(pin, 5, 2, pressureInchString); delay(100);&#125;// runs over and over againvoid loop() &#123; // Listenning for new clients WiFiClient client = server.available(); if (client) &#123; Serial.println(\"New client\"); // bolean to locate when the http request ends boolean blank_line = true; while (client.connected()) &#123; if (client.available()) &#123; char c = client.read(); if (c == '\\n' &amp;&amp; blank_line) &#123; getWeather(); client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); client.println(); // your actual web page that displays temperature client.println(\"&lt;!DOCTYPE HTML&gt;\"); client.println(\"&lt;html&gt;\"); client.println(\"&lt;head&gt;&lt;META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"15\\\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;ESP8266 Weather Webserver&lt;/h1&gt;&lt;h3&gt;Temperature = \"); client.println(temperatureFString); //client.println(\"&amp;deg;F&lt;/h3&gt;&lt;h3&gt;Humidity = \"); client.println(\"&amp;deg;C&lt;/h3&gt;&lt;h3&gt;Humidity = \"); client.println(humidityString); client.println(\"%&lt;/h3&gt;&lt;h3&gt;Pressure = \"); client.println(pressureString); client.println(\"hPa (\"); client.println(pressureInchString); client.println(\"Inch)&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;\"); break; &#125; if (c == '\\n') &#123; // when starts reading a new line blank_line = true; &#125; else if (c != '\\r') &#123; // when finds a character on the current line blank_line = false; &#125; &#125; &#125; // closing the client connection delay(1); client.stop(); Serial.println(\"Client disconnected.\"); &#125; if(count == 0)&#123; getWeather(); display.clear(); //display.drawString(10, 6, \"T=\"+String(t)+\"°F\"); display.drawString(10, 6, \"T=\"+String(t)+\"°C\"); display.drawString(10, 23, \"P=\"+String(p)+\"hPa\"); display.drawString(10, 40, \"RH=\"+String(h)+\"%\"); display.drawRect(0, 0, 127, 63); display.drawRect(1, 1, 125, 61); display.drawRect(2, 2, 124, 60); display.display(); Serial.print(\"Temperature = \"); Serial.print(bme.readTemperature()); Serial.println(\" °C\"); Serial.print(\"Pressure = \"); Serial.print(bme.readPressure() / 100.0F); Serial.println(\" hPa\"); Serial.print(\"Approx.Altitude = \"); Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA)); Serial.println(\" m\"); Serial.print(\"Humidity = \"); Serial.print(bme.readHumidity()); Serial.println(\" %\"); Serial.println(); &#125; count = count+1; if (count==10) count=0; delay(500);&#125; 该代码中包含一个非常基本的HTML网页的代码，输出BME280传感器数据。要注意的是，需要在程序中编辑SSID名称和密码以使其与WiFi网络匹配，然后再将其上载到ESP8266开发板上。 4. 显示效果将程序上传到ESP8266开发板后，ESP8266重新启动，会在串行监视器上打印出WiFi网络中为其分配的本地IP地址、温度、压力、估算高度。 为了通过Web服务器访问这些数据，在连接到同一WiFi网络的任何计算机、平板电脑或手机上打开Web浏览器，然后在URL字段中输入ESP8266 IP地址，然后按Enter键。ESP8266收到客户请求后，会提供一个包含BME传感器读数的网页，如下所示。 参考博客： 使用Arduino IDE的ESP8266和BME280（压力，温度，湿度） ESP8266和BME280创建一个本地/远程气象站","categories":[],"tags":[]},{"title":"解决电脑上GitHub网站打不开的问题","slug":"解决电脑上GitHub网站打不开的问题","date":"2020-08-22T18:06:56.436Z","updated":"2020-08-22T18:33:52.293Z","comments":true,"path":"2020/08/23/解决电脑上GitHub网站打不开的问题/","link":"","permalink":"http://xaviermin.github.io/2020/08/23/%E8%A7%A3%E5%86%B3%E7%94%B5%E8%84%91%E4%B8%8AGitHub%E7%BD%91%E7%AB%99%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"原因：本地DNS无法解析导致的。解决办法：修改hosts文件内容解决步骤：win10系统下操作","text":"原因：本地DNS无法解析导致的。解决办法：修改hosts文件内容解决步骤：win10系统下操作 第一步：电脑搜索记事本应用，以管理员身份运行，打开C盘中C:\\Windows\\System32\\drivers\\etc中的hosts文件。 第二步：通过站长工具找出DNS地址，进入站长工具网站的域名解析网址：http://tool.chinaz.com/dns/ ，在A类型的查询中输入github.com，找出最快的IP地址。 第三步：修改host文件中对应的github.com的IP地址。 第四步：保存host文件，即可打开GitHub网站。 网上有很多博客提供了解决这个问题的办法，试过几个，只有这个是适用我的，多尝试，不行就换另一种方法。 参考博客：https://blog.csdn.net/yuxikuo_1/article/details/107302871","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（四）","slug":"零基础快速学习Android开发（四）","date":"2020-08-22T17:55:54.141Z","updated":"2020-09-05T05:14:29.824Z","comments":true,"path":"2020/08/23/零基础快速学习Android开发（四）/","link":"","permalink":"http://xaviermin.github.io/2020/08/23/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"MQTT服务器的搭建——基于EMQ平台（Linux）EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器。Erlang/OTP是出色的软实时 (Soft-Realtime)、低延时 (Low-Latency)、分布式 (Distributed)的语言平台。EMQ X 设计目标是实现高可靠，并支持承载海量物联网终端的MQTT连接，支持在海量物联网设备间低延时消息路由。","text":"MQTT服务器的搭建——基于EMQ平台（Linux）EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器。Erlang/OTP是出色的软实时 (Soft-Realtime)、低延时 (Low-Latency)、分布式 (Distributed)的语言平台。EMQ X 设计目标是实现高可靠，并支持承载海量物联网终端的MQTT连接，支持在海量物联网设备间低延时消息路由。 EMQ X Broker 是基于高并发的 Erlang/OTP 语言平台开发，支持百万级连接和分布式集群架构，发布订阅模式的开源 MQTT 消息服务器。EMQ X Broker 在全球物联网市场广泛应用。无论是产品原型设计、物联网创业公司、还是大规模的商业部署，EMQ X Broker 都支持开源免费使用。 EMQ X 目前支持的操作系统: Centos6 Centos7 OpenSUSE tumbleweed Debian 8 Debian 9 Debian 10 Ubuntu 14.04 Ubuntu 16.04 Ubuntu 18.04 macOS 10.13 macOS 10.14 macOS 10.15 Windows Server 2019 产品部署建议 Linux 服务器，不推荐 Windows 服务器。 这是官方文档的建议，我因为看到这个建议所以选择在Linux系统中来搭建MQTT服务器，这就要求事先在电脑上装好Linux系统，安装模式和在Windows上应该差不多，大多都是命令行操作。 官方文档提供了在公众系统上安装EMQ X Broker的步骤，可供参考。 1.在Linux下安装EMQ X Broker1.1 下载EMQ X安装包话不多说，先上链接 -&gt; EMQ X Broker 打开下载链接后选择版本，例如我选择目前的最新版v4.2-rc.1，因为我使用的Liunx系统是Ubuntu16.04，所以选择Linux/Ubutu16.04/x86_64/zip。 我是直接下载的安装包，然后直接将压缩包复制粘贴到Linux系统中，另一种方法可以复制下载界面的下载链接，进入Linux的Terminal，输入命令进行下载。 1wget https://www.emqx.io/cn/downloads/broker/v4.2-rc.1/emqx-ubuntu16.04-4.2-rc.1-x86_64.zip 1.2 启动EMQ X Broker下载完成后，使用unzip命令解压，如果没有安装unzip，则使用命令sudo apt-get install unzip安装，还有一点需要注意的是，先查看压缩包放置在哪一级目录下，再解压。 1unzip emqx-ubuntu16.04-4.2-rc.1-x86_64.zip 解压需要一点时间，解压完之后，进入解压出来的emqx文件夹，使用命令启动即可。 1sudo .&#x2F;bin&#x2F;emqx start 启动成功会提示started successfully!字样。 然后可以使用命令查看emqx的状态。 如果要停止 EMQ X Broker，使用如下命令；如果要卸载 EMQ X Broker，直接删除 EMQ X 目录即可。 1sudo .&#x2F;bin&#x2F;emqx stop 1.3 验证进入控制台查看，EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。 打开浏览器，输入http://localhost:18083 来查看 Dashboard，默认用户名是 admin，密码是 public。 到此，MQTT服务器搭建成功！ 注意：在Linux下安装就要打开Linux下的浏览器查看，我在Windows的浏览器搜索半天显示不出来还以为安装过程有问题…… 2.EMQ X Dashboard2.1 简介EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，你可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。 2.2 启用 DashboardEMQ X Dashboard 功能由 emqx-dashboard 插件实现，该插件默认处于启用状态，它将在 EMQ X 启动时自动加载。如果你希望禁用 Dashboard 功能，你可以将 data/loaded_plugins（请参见 插件）中的 {emqx_dashboard, true} 修改为 {emqx_dashboard, false}。 1&#123;emqx_dashboard, true&#125; 2.3 查看 DashboardEMQ X Dashboard 是一个 Web 应用程序，你可以直接通过浏览器来访问它，无需安装任何其他软件。当 EMQ X 成功运行在你的本地计算机上且 EMQ X Dashboard 被默认启用时，你可以访问 http://localhost:18083 来查看你的 Dashboard，默认用户名是 admin，密码是 public。 详细内容见此链接Dashboard。","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（三）","slug":"零基础快速学习Android开发（三）","date":"2020-08-19T09:45:41.711Z","updated":"2020-08-22T17:55:26.227Z","comments":true,"path":"2020/08/19/零基础快速学习Android开发（三）/","link":"","permalink":"http://xaviermin.github.io/2020/08/19/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"Android Studio中导入jar包——导入MQTT jar包JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。JAR 文件非常类似 ZIP 文件——准确的说，它就是 ZIP 文件，所以叫它文件包。JAR（Java ARchive，Java 归档）是一种与平台无关的文件格式，可将多个文件合成一个文件。用户可将多个 Java applet 及其所需组件（.class 文件、图像和声音）绑定到 JAR 文件中，而后作为单个的简单 HTTP（Hypertext Tranfer Protocal，超文本传输协议）事务下载到浏览器中，从而大大提高下载速度。JAR 格式也支持压缩，从而减小了文件的大小，进一步缩短下载时间。","text":"Android Studio中导入jar包——导入MQTT jar包JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。JAR 文件非常类似 ZIP 文件——准确的说，它就是 ZIP 文件，所以叫它文件包。JAR（Java ARchive，Java 归档）是一种与平台无关的文件格式，可将多个文件合成一个文件。用户可将多个 Java applet 及其所需组件（.class 文件、图像和声音）绑定到 JAR 文件中，而后作为单个的简单 HTTP（Hypertext Tranfer Protocal，超文本传输协议）事务下载到浏览器中，从而大大提高下载速度。JAR 格式也支持压缩，从而减小了文件的大小，进一步缩短下载时间。 导入jar包的方法（通用） 首先去下载需要的jar包，MQTT jar包org.eclipse.paho.client.mqttv3-1.2.0.jar。 将jar包复制到Project下的app-&gt;libs目录下（如果不存在libs目录新建一个）。 右击该jar包，选择Add as library，弹出窗口，点击OK。 Build编译完成显示successful即成功导入jar包。","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（二）","slug":"零基础快速学习Android开发（二）","date":"2020-08-17T13:48:04.215Z","updated":"2020-08-22T17:56:27.148Z","comments":true,"path":"2020/08/17/零基础快速学习Android开发（二）/","link":"","permalink":"http://xaviermin.github.io/2020/08/17/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"控件与界面布局根据B站视频建立的一个MQTT工程，以这个为例，新建一个空白工程，API选择API 23:Android 6.0(Marshmaiiow)（避免错误，选择和up主一样）。下面一一介绍常用控件和界面布局的方法，以及控件与界面之间的通讯、事件的发生等等。常用控件：Button（按钮）、TextView（文本框）、EditText（编辑框）、ImageView（图片）、ProgressBar（进度）、AlertDialog与ProgressDialog（弹窗）。","text":"控件与界面布局根据B站视频建立的一个MQTT工程，以这个为例，新建一个空白工程，API选择API 23:Android 6.0(Marshmaiiow)（避免错误，选择和up主一样）。下面一一介绍常用控件和界面布局的方法，以及控件与界面之间的通讯、事件的发生等等。常用控件：Button（按钮）、TextView（文本框）、EditText（编辑框）、ImageView（图片）、ProgressBar（进度）、AlertDialog与ProgressDialog（弹窗）。 1.Button（按钮）默认情况下，系统会将button内的英文自动转换为大写，如果这不是你想要的效果，可以将textAllCaps属性设为false。 123456789&lt;Button android:layout_width=\"wrap_content\" android:text=\"确定\" android:textColor=\"#FFCC00\" android:textSize=\"16dp\" android:id=\"@+id/bt_1\" android:background=\"@color/colorPrimary\" android:layout_height=\"wrap_content\"&gt;&lt;/Button&gt; 第2、8行：设置按钮的大小，可将wrap_content（自适应大小）直接换成大小数值，如100dp； 第3-5行：设置文字及其属性（颜色、大小等）； 第6行：设置控件id，用来和JAVA文件通讯或者说是绑定事件的； 第7行：设置按钮的背景，可以是颜色(配色表)，可以是图标(图标库)图片，网上下载的图标必须是PNG格式，直接复制下载好的图标粘贴到项目的app-&gt;res-&gt;drawable目录下，然后替换参数； 2.TextView（文本框）android中所有控件都有android:layout_width和android:layout_height这两个属性。这两个属性的可选值有3个：match_parent，fill_parent和wrap_parent。其中，match_parent和fill_parent意义相同，官方更推荐使用match_parent。 1234567&lt;TextView android:layout_width=\"wrap_content\" android:textSize=\"30sp\" android:text=\"这是一个文本框\" android:id=\"@+id/text_1\" android:layout_height=\"wrap_content\"&gt;&lt;/TextView&gt; 3.EditText（编辑框）1234567&lt;EditText android:layout_width=\"wrap_content\" android:hint=\"请输入名称\" android:id=\"@+id/edit_1\" android:maxLines=\"2\" android:layout_height=\"wrap_content\"&gt;&lt;/EditText&gt; 第3行：表示输入框中的一段提示性文本； 第5行：表示输入框中可向下拓展的最大行数，超过这个行数则会产生滚动； 4.ImageView（图片）123456&lt;ImageView android:layout_width=\"wrap_content\" android:id=\"@+id/img_1\" android:src=\"@drawable/open\" android:layout_height=\"wrap_content\"&gt;&lt;/ImageView&gt; 第4行：选择图片资源，和图标一样，粘贴到项目app-&gt;res-&gt;drawable目录下的； 以上四个是常用控件，整体效果如下，后面的控件不常用。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center\" tools:layout_editor_absoluteX=\"0dp\" tools:layout_editor_absoluteY=\"0dp\"&gt; &lt;Button android:layout_width=\"50dp\" android:text=\"确定\" android:textColor=\"#FFCC00\" android:textSize=\"16sp\" android:id=\"@+id/bt_1\" android:background=\"@drawable/open\" android:layout_height=\"50dp\"&gt; &lt;/Button&gt; &lt;TextView android:layout_width=\"wrap_content\" android:textSize=\"30sp\" android:text=\"这是一个文本框\" android:id=\"@+id/text_1\" android:layout_height=\"wrap_content\"&gt; &lt;/TextView&gt; &lt;EditText android:layout_width=\"wrap_content\" android:hint=\"请输入名称\" android:id=\"@+id/edit_1\" android:maxLines=\"2\" android:layout_height=\"wrap_content\"&gt; &lt;/EditText&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:id=\"@+id/img_1\" android:src=\"@drawable/open\" android:layout_height=\"wrap_content\"&gt; &lt;/ImageView&gt; &lt;SeekBar android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;/SeekBar&gt;&lt;/LinearLayout&gt; 其他属性设置 布局方向：LinearLayout为线性布局，默认从左往右排列android:orientation=&quot;horizontal&quot;，可更改属性为垂直排列android:orientation=&quot;vertical&quot;； 居中排列：android:gravity=&quot;center&quot; 边缘空隙：android:layout_margin=&quot;20dp&quot; 权重（排列间隔）：android:layout_weight=&quot;1&quot; 线性排列内部居中：android:layout_gravity=&quot;center&quot;","categories":[],"tags":[]},{"title":"零基础快速学习Android开发（一）","slug":"零基础快速学习Android开发（一）","date":"2020-08-16T16:44:43.292Z","updated":"2020-08-18T08:56:27.689Z","comments":true,"path":"2020/08/17/零基础快速学习Android开发（一）/","link":"","permalink":"http://xaviermin.github.io/2020/08/17/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0Android%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Android介绍android开发是指android平台上应用的制作，Android早期由“Android之父”之称的Andy Rubin创办，Google于2005年并购了成立仅22个月的高科技企业Android，展开了短信、手机检索、定位等业务，基于Linux的通用平台进入了开发。Android是一种基于Linux的自由及开放源代码的操作系统，Android 分为四个层，从高层到低层分别是应用程 序层、应用程序框架层、系统运行库层和 Linux 内核层。","text":"Android介绍android开发是指android平台上应用的制作，Android早期由“Android之父”之称的Andy Rubin创办，Google于2005年并购了成立仅22个月的高科技企业Android，展开了短信、手机检索、定位等业务，基于Linux的通用平台进入了开发。Android是一种基于Linux的自由及开放源代码的操作系统，Android 分为四个层，从高层到低层分别是应用程 序层、应用程序框架层、系统运行库层和 Linux 内核层。 Android开发环境的搭建1.下载并安装配置jdk1.1下载jdk下载链接：Java SE Downloads 1.2安装、配置jdk由于之前实习学过Java的开发，安装过jdk并在电脑上已经配置好了的，这里就不详细面熟，网上有很多安装jdk的教程，可参考其他博客，推荐博客Android Studio开发环境搭建全攻略。 2.下载并安装Android Studio2.1下载Android studio下载链接：Android Studio 2.2安装Android studio这里遇到个问题，理论上这个界面安装时候会有Android SDK选项，但此处没有，先按步骤安装完程序，后面再解决这个问题。 点击Next，选择想要安装的路径，一路next。 安装完成后显示successfully。 安装成功后启动程序，会跳出这个对话框，如果是首次安装，选择Do not import settings，不导入之前版本的配置，如果以前安装过，且没有删除以前的配置信息，就选择Config or installation folder，然后点击OK，随后程序启动。 对话框询问，是否允许谷歌收集你使用Android Studio记录信息，以此帮助他们来优化软件，可以自行选择，我选择Don’t send。 显示无法访问到Android的SDK，先点击Cancel，这就是最开始提到的问题，没有安装Android SDK选项。 点击Cancel后，然后进入到了AndroidStudio的安装向导界面，点击next。 这里选择自定义安装，为的是后续我的SDK可以自行指定安装路径。 然后进入界面主题选择页面，我选择Darcula主题，喜欢亮度较高的主题可选择Light，然后点击下一步。 这里需要指定SDK的本地路径，如果之前电脑中已经存在SDK，可以指定该路径，后续就可以不用下载SDK，只会更新SDK；因为我是首次安装Android Studio，所以演示本地没有安装过SDK的场景，这里可以指定一个后续保存SDK的路径。 默认，下一步。 点击Finish，进行安装，这一步必须保证电脑在联网状态。 下载好以后，点击Finish，进入Android Studio的欢迎页面。 至此，AndroidStudio已经安装成功。安装完成后，以建立一个Helloworld项目为例，单击上图中的Start a new Android Studio project新建一个工程，进入下面的界面。 2.2 Android studio环境变量配置 首先右键我的电脑，点击【属性】，打开高级系统设置 点击【环境变量】，在系统变量下点击新建 添加变量名SDK_HOME和变量sdk位置 在系统变量里找到变量path，对其进行编辑，win10系统直接在列表中新建path变量：%SDK_HOME%\\tools 和 %SDK_HOME%\\platform-tools。如果你的系统中path变量为非列表形式，变量之间要用分号；隔开。 接下来检查SDK是否配置成功，使用 Windows+R 键，再输入cmd启动windows命令行界面，运行命令adb，出现以下信息表示SDK配置成功。 3.Gradle的下载与配置 Android Studio使用Gradle的目的在于帮助开发者管理项目依赖，开发部署，代码复用。 Gradle是一种构建工具，可以帮助开发者管理项目中的差异，依赖，编译，打包，部署等，可以定义满足自己需要的构建逻辑，写入到build.gradle中供日后复用。 Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。 Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven、Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。 3.1 下载Gradle先看需要安装哪个版本的gradle，不同版本的Android Studio应该是对应不同版本的gradle。 随便打开一个安卓工程，点击Help-&gt;About查看Android Studio版本 在工程根目录下打开gradle\\wrapper\\gradle-wrapper.properties，查看gradle版本，我的是gradle-6.1.1-all.zip。 1distributionUrl=https\\://services.gradle.org/distributions/gradle-6.1.1-all.zip 可在gradle主页下载相应版本的压缩包，一般地，在打开一个Android工程，如果没有下载安装gradle，软件会自动联网下载，但通常情况下下载都会非常慢，推荐在网上直接搜索需要的gradle版本进行下载，我是在CSDN下载的，有很多资源，如这个博客。 3.2 配置将下载好的gradle压缩包放在C:\\Users\\ASUS LD\\.gradle\\wrapper\\dists\\gradle-6.1.1-all\\cfmwm155h49vnt3hynmlrsdst目录下，正常情况下这里面还有.zip.lck和.zip.ok两个文件，并解压缩。 在Files-&gt;Settings中找到Gradle的配置，如果选择了下面的 Use Gradle from Specified location，那么就得检查目录是否设置正确，此时地址是C:\\Users\\ASUS LD\\.gradle\\wrapper\\dists\\gradle-6.1.1-all。 3.3 环境变量的添加这一步是我在安装的过程中，看到网上有些博主说的，不知道有没有用，反正我添加了… 在我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建系统变量，变量名为GRADLE_HOME，变量值为解压后的gradle文件中的bin目录下。 在Path中添加%GRADLE_HOME%\\bin，确定 环境变量添加完成。","categories":[],"tags":[]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2020-08-13T14:04:36.463Z","updated":"2020-08-13T17:14:03.050Z","comments":true,"path":"2020/08/13/Markdown常用语法/","link":"","permalink":"http://xaviermin.github.io/2020/08/13/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"什么是MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字。","text":"什么是MarkdownMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 1.基本语法1.1 字体设置斜体、粗体、删除线语法如下： *这里是文字* _这里是文字_ //倾斜 **这里是文字** //加粗 ***这里是文字*** //倾斜加粗 ~~这里是文字~~ //删除线效果如下：这里是文字 这里是文字这里是文字这里是文字这里是文字 1.2 分级标题语法如下： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题1.3 链接语法如下： 直接显示网址链接：&lt;网址&gt; 插入超链接：文字+链接网址 插入图片：见另一篇博客（Markdown添加图片） 1.4 分割线语法如下：在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西，也可以在星号，或是减号中间插入空格。 1.5 代码块语法如下： 利用缩进(tab),首行缩进一个字符。 利用英文 ``` 符号包裹代码。` 行内式：main` 直接运行html代码 1.6 引用语法如下： 1.在被引用的文本前加上&gt;符号，以及一个空格，如果只输入了一个&gt;符号会产生一个空白的引用。 2.引用的嵌套使用效果如下： 文字 文字 1.7 列表语法如下： 1.无序列表：使用*，+，-，后加一个空格，再加文字。 2.有序列表：使用数字和一个英文句点。 3.列表嵌套：上一级和下一级之间敲三个空格即可。效果如下： 列表文字 列表文字 列表文字 列表文字 列表文字 列表文字 列表文字 列表文字 1.8 表格语法如下： 文字|文字|文字 -|-|- :-:|:-:|:-: -:|-:|-: //左对齐 居中 右对齐 文字|文字|文字 文字|文字|文字效果如下： 文字 文字 文字 文字 文字 文字 文字 文字 文字 2.快捷键 功能 快捷键 加粗 Ctrl+B 斜体 Ctrl+I 引用 Ctrl+Q 插入链接 Ctrl+L 插入代码 Ctrl+K 插入图片 Ctrl+G 提升标题 Ctrl+H 有序列表 Ctrl+O 无序列表 Ctrl+U 横线 Ctrl+R 撤销 Ctrl+Z 重做 Ctrl+Y 3.特殊用法3.1 制作一份待办事宜 语法如下： - [ ] 文字 待办 - [x] 文字 已办 效果如下： 文字 文字 3.2 书写公式语法如下： $$公式$$3.3 绘制流程图语法如下： 12345678st&#x3D;&gt;start: Startop&#x3D;&gt;operation: Your Operationcond&#x3D;&gt;condition: Yes or No?e&#x3D;&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op效果如下： 12345678st&#x3D;&gt;start: Startop&#x3D;&gt;operation: Your Operationcond&#x3D;&gt;condition: Yes or No?e&#x3D;&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 3.4 绘制序列图语法如下： 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!3.5 绘制甘特图语法如下： 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d","categories":[],"tags":[]},{"title":"Markdown添加图片","slug":"Markdown添加图片","date":"2020-08-12T13:47:39.144Z","updated":"2020-08-13T08:36:43.401Z","comments":true,"path":"2020/08/12/Markdown添加图片/","link":"","permalink":"http://xaviermin.github.io/2020/08/12/Markdown%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/","excerpt":"百度Markdown添加图片，看到最多的就是以下这几种方法,各种Markdown编辑器的插图方式也都包含在这几种方法之内。插图的基础格式：![text](图片链接 &quot;optional title&quot;) text：图片的Alt标签，用来描述图片的关键词，可以不写。 图片链接：可以是图片的本地地址或者是网址。 “optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。","text":"百度Markdown添加图片，看到最多的就是以下这几种方法,各种Markdown编辑器的插图方式也都包含在这几种方法之内。插图的基础格式：![text](图片链接 &quot;optional title&quot;) text：图片的Alt标签，用来描述图片的关键词，可以不写。 图片链接：可以是图片的本地地址或者是网址。 “optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。 1.插入本地图片只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。 格式为：![text](本地文件路径) 缺点：不灵活不好分享，本地图片的路径更改或丢失都会造成markdown文件调不出图。 2.插入网络图片只需要在基础语法的括号中填入图片的网络链接即可，现在已经有很多免费/收费图床和方便传图的小工具可选。 格式为：![text](网络图片路径) 缺点：将图片存在网络服务器上，非常依赖网络。 3.把图片存入markdown文件用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 格式为：![text][base64str] 缺点：有点麻烦，需要将图片转化为base64字符串，用到Python 使用python将图片转化为base64字符串 12345import base64f=open('723.png','rb') #二进制方式打开图文件ls_f=base64.b64encode(f.read()) #读取文件内容，转换为base64编码f.close()print(ls_f) base64字符串转化为图片 123456import base64bs='iVBORw0KGgoAAAANSUhEUg....' # 太长了省略imgdata=base64.b64decode(bs)file=open('2.jpg','wb')file.write(imgdata)file.close() 4.利用Github在Markdown中插入图片利用GitHub上传图片，并在Markdown中插入是较为稳妥和方便的方法，使用GitHub上传图片，主要分为4步： 1.先注册一个github的帐号 2.创建一个专门放图片的仓库 3.上传图片 4.上传完成后，点击打开图片，右键复制图片链接，加入到Markdown文件中 具体步骤参考这篇博客详细介绍，我尝试这种方法在GitHub上传完照片后点击图片显示不出来，按照百度的解决办法操作后，GitHub网站又进不去…放弃了，也不知道图片显示不了的问题解决没，而且向GitHub上传图片的操作有点麻烦，上传完照片每次取连接也不方便。 5.将图片上传至图床把写博客需要的所有图片保存到某个图床服务里，然后获取该图片的网络图床链接写在博客里，就可以显示图片了，相当于插入网络图片。我使用的是路过图床，提供高速稳定的图片上传和分享服务，而且免费！！！ 步骤如下： 1.路过图床官网注册账号 2.上传图片到图床 3.将图片URL链接添加到Markdown文件中就可以显示出图片了 推荐使用这种方法，上传图片方便快捷，可批量上传，上传后的图片一直保存在图床就OK。","categories":[],"tags":[]},{"title":"Hexo博客页面美化","slug":"Hexo博客页面美化","date":"2020-08-12T07:32:42.030Z","updated":"2020-08-13T16:58:09.211Z","comments":true,"path":"2020/08/12/Hexo博客页面美化/","link":"","permalink":"http://xaviermin.github.io/2020/08/12/Hexo%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/","excerpt":"前言：原来的界面使用的是yilia主题，下面采用volantis主题进行美化设计，博客主题可在Themes网站下载喜欢的，下载好的压缩包添加到博客文件内的themes文件夹中，修改_config.yml文件主题名称，原博客主题界面如下图所示。","text":"前言：原来的界面使用的是yilia主题，下面采用volantis主题进行美化设计，博客主题可在Themes网站下载喜欢的，下载好的压缩包添加到博客文件内的themes文件夹中，修改_config.yml文件主题名称，原博客主题界面如下图所示。 一、页面优化1.导航栏样式在原基础上添加了一个渐变背景。首先在主题配置文件_config.yml中navbar的effext毛玻璃特效（blur）去掉。 123456将第5行改成第6行：navbar: height: 64px width: auto # auto, max effect: [shadow, blur] # [shadow, floatable, blur] effect: [shadow] # [shadow, floatable] 在themes\\volantis\\source\\css_layout\\navbar.styl中，添加代码 123456789101112添加第11行代码：.l_header $iconW = 32px $iconMargin = 4px position: fixed z-index: 1000 top: 0 width: 100% height: $navbar-height background: $color-card background-image: linear-gradient(to top, #5ee7df 0%, #b490ca 100%) box-shadow: $boxshadow-card #5ee7df0%, #b490ca100%中的#5ee7df、#b490ca代表两种颜色，从0%到100%渐变，可修改这两个参数改变颜色，免费的CSS渐变背景样式网站——CSS渐变背景。 效果如下： 2.页面卡片阴影在主页面中的文章、侧边栏添加一点阴影，并在鼠标悬停时出现阴影。 主页文章：在\\themes\\volantis\\source\\css\\_layout中main.styl文件，找到.post-wrapper属性 123456789添加5-9行代码：.post-wrapper column-break-inside: avoid break-inside: avoid-column box-shadow: 0 1px 20px -6px rgba(0,0,0,0.5) border-radius: 8px transition: box-shadow .5s ease &amp;:hover box-shadow:0px 1px 20px 1px rgba(0,0,0,0.5) 侧边栏：在themes\\volantis\\source\\css_layout中sidebar.styl文件，找到.widget属性 123456789101112添加9-12行代码：.widget z-index: 0 background: $color-card margin-top: $gap border-radius: $border-card width: 100% display: none box-shadow: 0 1px 20px -6px rgba(0,0,0,0.5) transition: box-shadow .5s ease &amp;:hover box-shadow:0px 1px 20px 1px rgba(0,0,0,0.5) 效果如下： 3.页面特效在themes\\volantis\\layout中layout.ejs文件的body里面直接引用，添加鼠标点击社会主义价值观特效和鼠标滑动特效。 12345678添加7、8行代码：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;%- partial('_partial/head') %&gt;&lt;body&gt; &lt;%- partial('_partial/cover') %&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/zyoushuo/Blog/hexo/js/clicksocialist.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/zyoushuo/Blog/hexo/js/mouse_slide.js\"&gt;&lt;/script&gt; 效果如下： 4.主页、正文文章标题居中在themes\\volantis\\source\\css_layout\\main.styl中添加代码，使得主页面的文章、文章正文、关于/友链/留言板等自定义页面的标题居中。 123456789添加第9行代码：.post-wrapper margin-bottom: $gap .post div.meta margin-bottom: $gap .title font-size: $fontsize-h2+ text-align: center 123456添加第5行代码： .title trans(.1s) margin: 0+ text-align: center color: $color-text 5.修改卡片的内外边距在_config.yml文件中找到.gap的设置，添加base值，大小为要设置的内外边距。 12345678修改代码：gap: base: 10px h2: 48px # Spacing above H2 (only px unit) h3: 24px # Spacing above H3 (only px unit) h4: 16px # Spacing above H4 (only px unit) line: .51rem # 段落行间距 inline: .5rem # 段落内部行间距 6.修改侧边栏头像在_config.yml文件中找到avatar的设置，将原头像地址改成想要换的头像地址，前提是头像图片是网络图片，大小在150x150适中，形状可在shape处改成圆形或矩形。 12345678910111213# widget librarywidget: blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://s1.ax1x.com/2020/08/13/dS4nTs.png # avatar: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png shape: rectangle # circle, rectangle url: /about/ title: subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: true 页面中有些地方使用的小图标在网站Font Awesome中获取。 7.文章末尾版权 参考博客： 1.Volantis主题DIY笔记 2.hexo之Volantis主题美化 3.","categories":[],"tags":[]},{"title":"Python入门笔记","slug":"Python入门笔记","date":"2020-08-11T20:33:37.873Z","updated":"2020-08-22T18:02:54.054Z","comments":true,"path":"2020/08/12/Python入门笔记/","link":"","permalink":"http://xaviermin.github.io/2020/08/12/Python%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","excerpt":"1. Python基本语法元素1.1 编译和解释（程序执行的两种方式） 编译：将源代码一次性转换成目标代码的过程。 解释：将源代码逐条转换成目标代码同时逐条运行的过程。（类似实时的同声传译） 根据程序这两种执行方式，可以将编程语言分为两类：静态语言和脚本语言。 静态语言：C/C++、Java语言等。编译器一次性生成目标代码，优化更充分，程序运行速度更快。 脚本语言：Python、JavaScript、PHP等。执行程序时需要源代码，维护更灵活，同时保留源代码可以使程序功能可跨多个操作系统平台运行。","text":"1. Python基本语法元素1.1 编译和解释（程序执行的两种方式） 编译：将源代码一次性转换成目标代码的过程。 解释：将源代码逐条转换成目标代码同时逐条运行的过程。（类似实时的同声传译） 根据程序这两种执行方式，可以将编程语言分为两类：静态语言和脚本语言。 静态语言：C/C++、Java语言等。编译器一次性生成目标代码，优化更充分，程序运行速度更快。 脚本语言：Python、JavaScript、PHP等。执行程序时需要源代码，维护更灵活，同时保留源代码可以使程序功能可跨多个操作系统平台运行。 1.2 求解计算问题的精简步骤 确定IPO：明确计算部分及功能边界。 编写程序：将计算求解的设计变成现实。 调试程序：确保程序按照正确逻辑能够正确运行。 1.3 Python的两种编程方式 交互式：对每个输入语句即时运行结果，适合语法练习。 文件式：批量执行一组语句并运行结果，是编程的主要方式。 1.4 实例1：温度转换编写程序实现，输入摄氏温度，转换成华氏温度输出，输入华氏温度转换成摄氏温度输出。 12345678910#Tem_change.pyTempStr &#x3D; input (&quot;请输入带有符号的温度值: &quot;)if TempStr[-1] in [&#39;F&#39;, &#39;f&#39;] : C &#x3D; (eval(TempStr[0:-1]) - 32) &#x2F; 1.8 print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))elif TempStr[-1] in [&#39;C&#39;, &#39;c&#39;] : F &#x3D; 1.8 * eval(TempStr[0:-1]) + 32 print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))else: print(&quot;输入格式错误，请重新输入！&quot;) 分别输入36C、88F，程序输出结果分别为96.80F、31.11C。 1.5 Pythonn程序语法元素分析 单行注释：以#开头，其后内容为注释。 多行注释：以&#39;&#39;&#39;开头和结尾。 字符串表示：TempStr[-1]表示TempStr字符串的最后一个字符 切分：TempStr[0:-1]表示TempStr字符串从第一个字符开始但不到最后一个字符 print函数：例print(“转换后的温度是{:.2f}F”.format(F))，{:.2f}表示槽，后续变量填充到槽中，此处将变量F填充到这个位置并取小数点后两位。 eval函数（评估函数）：去掉参数最外侧引号并执行余下语句的函数。123456789例子：&gt;&gt;&gt;eval(&quot;1&quot;)1&gt;&gt;&gt;eval(&quot;1+2&quot;)3&gt;&gt;&gt;eval(&#39;&quot;1+2&quot;&#39;)&#39;1+2&#39; #输出只保留单引号&gt;&gt;&gt;eval(&#39;print(&quot;Hello&quot;)&#39;)Hello format函数：一种格式化输出字符串的函数（str.format）,基本语法是通过｛｝和：来代替以前的%。详细参考[format函数之几种常规用法][1] 2. Python基本图形绘制2.1 实例2：Python蟒蛇绘制这是Python蟒蛇绘制的全部代码，第2行impor是保留字，引入了一个绘图库turtle。 1234567891011121314151617#Snake_fig.pyimport turtleturtle.setup(650, 350, 200, 200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(&quot;red&quot;)turtle.seth(-40)for i in range(4): turtle.circle(40, 80) turtle.circle(-40, 80)turtle.circle(40, 80&#x2F;2)turtle.fd(40)turtle.circle(16, 180)turtle.fd(40 * 2&#x2F;3)turtle.done() 2.2 turtle库的使用turtle（海龟）库是turtle绘图体系的Python实现。 turtle的绘图窗体：turtle.setup(width, height, startx, starty)，setup()设置窗体大小及位置，(startx, starty)两个参数省略系统默认窗口在屏幕正中心。 前进：turtle.fd(d)，fd() 括号里输入前进距离。 旋转角度：turtle.seth(angle)，seth()，括号里输入旋转的角度。 画圆：turtle.circle(r, angle)，表示以当前位置左侧某一点为圆心，进行曲线运动。 方向控制函数：turtle.seth(angle)，改变行径方向，angle为绝对坐标角度。 循环语句：for i in range(4):，循环4次，range()函数产生循环计数序列。range(N)即产生0到N-1的整数序列，共N个；range(M,N)产生M到N-1的整数序列，共N-M个。 done函数：turtle.done()，文件式描写方法中，该函数作为turtle绘制的最后一部分，程序运行之后程序不会退出，需要手工关闭窗体退出。 3. 基本数据类型3.1 数字类型及操作 整数类型：pow(x,y)函数，计算x的y次方。 浮点数类型：带有小数点及小数的数字，浮点数间运算存在不确定尾数（不是bug）。浮点数间运算及比较用round(x,d)函数辅助，对x四舍五入，d是小数截取位数，不确定尾数一般发生在10e-16（aeb表示a*10的b次方）左右。 复数类型：与数学中复数的概念一致。 数值运算操作符： 操作符及使用 描述 x+y 加，x与y之和 x-y 减，x与y之差 x*y 乘，x与y之积 x/y 除，x与y之商 10/3结果是3.3333333333333335 x//y 整数除，x与y之整数商 10/3结果是3 +x x本身 -y y的负值 x%y 余数，模运算 10%3结果是1 x**y 幂运算，x的y次幂，当y是小数时为开放运算 数值运算函数： 函数及使用 描述 abs(x) 绝对值，x的绝对值 abs(-10)结果为10 divmod(x,y) 商余，(x//y,x%y)，同时输出商和余数，divmod(10,3)结果为(3,1) pow(x,y[,z]) 幂余，(x**y)%z，pow(3,pow(3,99),10000)结果为4587 round(x,d) 四舍五入，d是保留小数位数，round(-10.123,2)结果为-10.12 max(X1,X2,…,Xn) 最大值，返回X1,X2,…,Xn中最大值，n不限 min(X1,X2,…,Xn) 最小值，返回X1,X2,…,Xn中最小值，n不限 int(x) 将x变成整数，舍弃小数部分，也可将字符型变成整数 float(x) 将x变成浮点数，增加小数部分，也可将字符型变成浮点数 complex(x) 将x变成复数，增加虚数部分 3.2 字符串类型及操作 字符串切片用法： &lt;字符串&gt;[M:N]，M缺失表示至开头，N缺失表示至结尾。例：”一二三四五六七八九” [:3]结果是”一二三”&lt;字符串&gt;[M:N:K]，根据步长K对字符串切片。例：”一二三四五六七八九” [1:8:2]结果是”二四六八”“一二三四五六七八九” [::-1]结果是”九八七六五四三二一” 字符串操作符： 操作符及使用 描述 x+y 连接两个字符串x和y nx 或 xn 复制n次字符串x x in s 如果x是s的子串，返回True，否则返回False 字符串处理函数： 函数及使用 描述 len(x) 长度，返回字符串x的长度，len(“一二三456”)结果为6 str(x) 任意类型x所对应的字符串形式，str(1.23)—“1.23”，str([1,2])—[1,2]，与eval()函数功能相反。 hex(x)或oct(x) 整数x的十六进制或八进制小写形式字符串，hex(425)—“0x1a9”，oct(425)—“0o651” chr(u) u为Unicode编码，返回其对应的字符 ord(x) x为字符，返回其对应的Unicode编码 字符串处理方法： 方法及使用 描述 str.lower()或str.upper 返回字符串的副本，全部字符小写/大写，”AbCdEfGh”.lower()结果为”abcdefgh” str.split(sep=None) 返回一个列表，由str根据sep被分隔的部分组成，”A,BC,DEF”.split(“,”)结果为[‘A’,’BC’,’DEF’] str.count(x) 返回子串x在str中出现的次数，”i love you”.count(“o”)结果为2 str.replace(old,new) 返回字符串str副本，所有old子串被替换为new，”python”.replace(“n”,”n123.io”)结果为”python123.io” str.center(width[,fillchar]) 字符串str根据宽度width居中，fillchar可选，”python”.center(20,”=”)结果为”=======python=======” str.strip(chars) 从str中去掉chars中列出的字符，”= python “.strip(“ np”)结果为”ytho” str.join(iter) 在iter变量除最后元素外每个元素后增加一个str，”,”.join(“12345”)结果为”1,2,3,4,5” 字符串类型的格式化：格式化是对字符串进行格式表达的方式，使用.format()方法,共有6个控制格式，分别为填充、对齐、宽度、,、.精度、类型，用法如下 &lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)例：“{0:=^20}”.format(“PYTHON”)——“=======PYTHON=======”“{0:&gt;20}”.format(“PYTHON”)——“*****PYTHON”“{:10}”.format(“PYTHON”)——“PYTHON “ #默认左对齐“{0:,.2f}”.format(12345.6789)——‘12,345.68’“{0:b},{0:d},{0:o},{0:x},{0:X}”.format(425)——‘110101001,425,651,1a9,1A9’“{0:e},{0:f},{0:%}”.format(3.14)——‘3.140000e+00,3.140000,314.000000%’ 3.3 time库的使用 time库基本介绍：是Python中处理时间的标准库。123456import timetime.&lt;b&gt;()##### time库包括三类函数 #####1.时间获取：time() ctime() gmtime()2.时间格式化：strftime() strptime()3.程序计时：sleep() perf_counter() 时间获取： 函数 描述 time() 获取当前时间戳，即计算及内部时间值，浮点数，表示从1970年1月1日0:00开始到当前时刻为止以秒为单位的数值，1596959041.034725 ctime() 获取当前时间并以易读方式表示，返回字符串，’Sun Aug 9 15:44:30 2020’ gmtime() 获取当前时间，表示为计算机可处理的时间格式，time.struct_time(tm_year=2020, tm_mon=8, tm_mday=9, tm_hour=7, tm_min=45, tm_sec=41, tm_wday=6, tm_yday=222, tm_isdst=0) 时间格式化： 函数 描述 strftime(tpl,ts) tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量，&gt;&gt;&gt;t=time.gmtime()&gt;&gt;&gt;time.strftime(“%Y-%m-%d %H:%M:%S”,t)输出’2020-08-09 07:52:17’ strptime(str,tpl) str是字符串形式的时间值，tpl是格式化模板字符串，用来定义输入效果，&gt;&gt;&gt;timeStr = ‘2020-08-09 16:03:30’&gt;&gt;&gt;time.strptime(timeStr, “%Y-%m-%d %H:%M:%S”)输出time.struct_time(tm_year=2020, tm_mon=8, tm_mday=9, tm_hour=16, tm_min=3, tm_sec=30, tm_wday=6, tm_yday=222, tm_isdst=-1) 各字符代表的含义如下表所示： 格式化字符串 日期/时间说明 格式化字符串 日期/时间说明 %Y 年份 %m 月份（数字） %B 月份名称 %b 月份名称缩写 %d 日期 %A 星期 %p 上/下午 %a 星期缩写 %H 小时（24h制） %I 小时（12h制） %M 分钟 %S 秒 程序计时应用： 函数 描述 perf_counter() 测量时间函数，返回CPU级别的精确时间计数值，单位为秒，由于计数值起点不确定，连续调用取差值才有意义 sleep(s) 产生时间函数，s为休眠的时间，单位秒，可以是浮点数 3.4 实例：文本进度条1.文字显示进度，代码如下： 12345678910111213141516171819202122232425import timescale &#x3D; 10print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;执行开始&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)for i in range(scale+1): a &#x3D; &#39;*&#39; * i b &#x3D; &#39;.&#39; * (scale - i) c &#x3D; (i&#x2F;scale) * 100 print(&quot;&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c,a,b)) time.sleep(0.1)print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;执行结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)运行效果：&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;执行开始&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 0 %[-&gt;..........]10 %[*-&gt;.........]20 %[**-&gt;........]30 %[***-&gt;.......]40 %[****-&gt;......]50 %[*****-&gt;.....]60 %[******-&gt;....]70 %[*******-&gt;...]80 %[********-&gt;..]90 %[*********-&gt;.]100%[**********-&gt;]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;执行结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2.单行动态刷新，代码如下： 1234567import timefor i in range(101): print(&quot;\\r当前进度&#123;:&#125;%&quot;.format(i), end&#x3D;&quot;&quot;) time.sleep(0.1) 运行效果：当前进度66% #直到100% 3.完整版单行动态刷新，代码如下： 1234567891011121314151617import timescale &#x3D; 50print(&quot;执行开始&quot;.center(scale&#x2F;&#x2F;2, &quot;&#x3D;&quot;))start &#x3D; time.perf_counter()for i in range(scale+1): a &#x3D; &#39;*&#39; * i b &#x3D; &#39;.&#39; * (scale - i) c &#x3D; (i&#x2F;scale) * 100 dur &#x3D; time.perf_counter() - start print(&quot;\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;&quot;.format(c,a,b,dur), end&#x3D;&quot;&quot;) time.sleep(0.1)print(&quot;\\n&quot; + &quot;执行结束&quot;.center(scale&#x2F;&#x2F;2, &quot;&#x3D;&quot;))运行效果：&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;执行开始&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;100%[**************************************************-&gt;]5.03&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;执行结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 4. 程序的控制结构4.1 程序的分支结构1234567if &lt;条件&gt;: # :不能漏 &lt;语句块&gt;#二(多)分支结构if &lt;条件&gt;: &lt;语句块1&gt;else: &lt;语句块2&gt; 程序的异常处理，结构如下： 1234567891011try : &lt;语句块1&gt;except : #可添加异常类型标记，except &lt;异常类型&gt;: &lt;语句块2&gt; #例:try : num &#x3D; eval(input(&quot;请输入一个整数:&quot;)) print(num**2)except : #except NameError: NameError为一种异常类型名称 print(&quot;输入的不是整数&quot;) 4.2 程序的循环结构 遍历循环（for循环）：遍历某个结构形式的循环运行方式。 123456789101112131415for &lt;循环变量&gt; in &lt;遍历结构&gt; : # : 不能漏 &lt;语句块&gt; 1.计数循环（N次）for i in range(M,N,K) : #从M到N，以K为步长 &lt;语句块&gt;2.字符串遍历循环for c in s : &lt;语句块&gt;3.列表遍历循环for item in ls : &lt;语句块&gt;4.文件遍历循环for line in fi : &lt;语句块&gt; 无限循环（while循环）：由条件控制的循环运行方式。 12while &lt;条件&gt; : &lt;语句块&gt; 循环控制保留字：break和continuebreak：跳出并结束当前整个循环，执行循环后的语句。continue：结束当次循环，继续执行后续次数循环。 4.3 random库的使用random库是使用随机数的Python标准库，用于生成随机数，使用方法import random。基本随机数函数：seed(),random()扩展随机数函数：randint(),getrandbits(),uniform(),randrange(),choice(),shuffle() 函数 描述 seed(a=None) 初始化给定的随机数种子，默认为当前系统时间，&gt;&gt;&gt;random.seed(10) #产生种子10对应的序列 random() 生成一个[0.0,1.0]之间的随机小数，&gt;&gt;&gt;random.random()&gt;&gt;&gt;0.9363138024400508 randint(a,b) 生成一个[a,b]之间的整数，&gt;&gt;&gt;random.randint(10,100)&gt;&gt;&gt;51 randrange(m,n[,k]) 生成一个[m,n]之间以k为步长的随机整数，&gt;&gt;&gt;random.randrange(10,100,10)&gt;&gt;&gt;70 uniform(a,b) 生成一个[a,b]之间的随机小数，&gt;&gt;&gt;random.uniform(10,100)&gt;&gt;&gt;46.482745366926494 getrandbits(k) 生成一个k比特长的随机整数，&gt;&gt;&gt;random.getrandbits(5)&gt;&gt;&gt;27 choice(seq) 从序列seq中随机选择一个元素，&gt;&gt;&gt;random.choice([1,2,3,4,5])&gt;&gt;&gt;3 shuffle(seq) 将序列seq中元素随机排列，返回打乱后的顺序，&gt;&gt;&gt;s=[1,2,3,4,5];random.shuffle(s);print(s)&gt;&gt;&gt;[1, 2, 4, 3, 5] 5. 函数和代码复用5.1 函数的定义与使用 函数的理解与定义 函数是一段代码的表示、是一段具有特定功能的可重用的语句组、是一种功能的抽象、降低编程难度和代码复用。 12345678910def &lt;函数名&gt;(&lt;参数(0个或多个)&gt;) : &lt;函数体&gt; return &lt;返回值&gt; 例：计算n！def fact(n) : s &#x3D; 1 for i in range(1, n+1): s *&#x3D; i return s 局部变量和全局变量使用规则： 1.基本数据类型，无论是否重名，局部变量与全局变量不同2.可以通过global保留字在函数内部声明全局变量3.组合数据类型，如果局部变量未真实创建，则是全局变量 lambda函数 lambda函数返回函数名作为结果 12345678910&lt;函数名&gt; &#x3D; lambda &lt;参数&gt; : &lt;表达式&gt;例：f &#x3D; lambda x, y : x + yf(10, 15)25f &#x3D; lambda : &quot;lambda函数&quot;print(f())lambda函数 5.2 实例：七段数码管的绘制主要是熟悉函数的定义与调用，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import turtle, timedef drawGap() : #每段数码管添加间隔，更美观 turtle.penup() turtle.fd(5)def drawLine(draw) : #绘制单段数码管 drawGap() turtle.pendown() if draw else turtle.penup() turtle.fd(40) drawGap() turtle.right(90)def drawDigit(digit) : #根据数字绘制七段数码管 drawLine(True) if digit in [2, 3, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 1, 3, 4, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 3, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 6, 8] else drawLine(False) turtle.left(90) drawLine(True) if digit in [0, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 3, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 1, 2, 3, 4, 7, 8, 9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20)# def drawData(data) : #获取要输出的数字# for i in data :# drawDigit(eval(i)) #通过eval()函数将数字变为整数def drawData(data) : #data为日期，格式为&#39;%Y-%m&#x3D;%d+&#39; turtle.pencolor(&quot;red&quot;) for i in data : if i &#x3D;&#x3D; &#39;-&#39; : turtle.write(&#39;年&#39;, font&#x3D;(&quot;Arial&quot;, 24, &quot;normal&quot;)) turtle.pencolor(&quot;green&quot;) turtle.fd(40) elif i &#x3D;&#x3D; &#39;&#x3D;&#39; : turtle.write(&#39;月&#39;, font&#x3D;(&quot;Arial&quot;, 24, &quot;normal&quot;)) turtle.pencolor(&quot;blue&quot;) turtle.fd(40) elif i &#x3D;&#x3D; &#39;+&#39; : turtle.write(&#39;日&#39;, font&#x3D;(&quot;Arial&quot;, 24, &quot;normal&quot;)) else: drawDigit(eval(i))def main() : turtle.setup(800, 350, 200, 200) turtle.penup() turtle.fd(-300) turtle.pensize(5) # drawData(&#39;20200810&#39;) drawData(time.strftime(&#39;%Y-%m&#x3D;%d+&#39;, time.gmtime())) turtle.hideturtle() turtle.done()main() 5.3 代码复用与函数递归 函数递归的理解：即函数调用函数自身，比如计算阶乘n*(n-1)!。 函数递归实例：字符串反转12345678910111213141516def rvs(s) : #字符串反转函数 if s &#x3D;&#x3D; &quot;&quot; : return s else : return rvs(s[1:])+s[0]def main() : s &#x3D; input (&quot;请输入字符串: &quot;) st &#x3D; rvs(s) print(&quot;反转后的字符串为：&#123;&#125;&quot;.format(st))main()运行效果：请输入字符串: 123456789反转后的字符串为：987654321 5.4 Pyinstaller库的使用Pyinstaller库是第三方库，可将源代码转换成无需源代码的可执行文件。 安装Pyinstaller库：Windows环境下打开cmd命令行，输入pip install pyinstaller命令，pip指令安装库的时候连接互联网，从互联网上自动下载安装包，并安装执行，安装之后会提示Successfully installed即安装完成。 Pyinstaller库使用：以七段数码管为例，文件名为seg.py，在该文件所在目录下执行命令pyinstaller -F seg.py,转换成功后在所在文件夹中会新增名为dist文件夹，里面有seg.exe可执行程序，双击即可。 Pyinstaller库常用参数： 参数 描述 -h 查看帮助 –clean 清理打包过程中的临时文件 -D 默认值，生成dist文件夹 -F 在dist文件夹中只生成独立的.exe文件（推荐使用） -i &lt;图标文件名.ico&gt; 指定打包程序使用的图标（ico）文件，例：pyinstaller -i xxx.ico -F seg.py 6. 组合数据类型6.1 集合类型及操作 集合三重点： 1.集合用大括号{}表示，元素间用逗号分隔2.集合中每个元素唯一，不存在相同元素3.集合元素之间无序 6个操作符 操作符及应用 描述 S1T(1表竖线) 并，返回一个新集合，包括在集合S和T中的所有元素 S-T 差，返回一个新集合，包括在集合S但不在T中的元素 S&amp;T 交，返回一个新集合，包括同时在集合S和T中的元素 S^T 补，返回一个新集合，包括集合S和T中的非相同元素 S&lt;=T或S&lt;T 返回True/False，判断S和T的子集关系 S&gt;=T或S&gt;T 返回True/False，判断S和T的包含关系 集合处理方法 操作函数或方法 描述 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x，如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S中的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回集合S的一个副本 len(S) 返回集合S的元素个数 x in S 判断S中元素x，x在集合S中，返回True，否则返回False x not in S 判断S中元素x，x不在集合S中，返回True，否则返回False set(x) 将其他类型变量x转变为集合类型 6.2 序列类型及操作 序列类型：序列是具有先后关系的一组元素 1.序列是一维元素向量，元素类型可以不同2.元素间由序号引导，通过下标访问序列的特定元素 6个操作符 操作符及应用 描述 x in s 如果x是序列s的元素，返回True，否则返回False x not in s 如果x是序列s的元素，返回False，否则返回True s+t 连接两个序列s和t sn或ns 将序列s复制n次 s[i] 索引，返回s中的第i个元素，i是序列的序号 s[i:j]或s[i:j:k] 切片，返回序列s中第i到j以k为步长的元素子序列 序列类型通用函数和方法 5个函数和方法 描述 len(s) 返回序列s的长度 min(s) 返回序列s的最小元素，s中元素需要可比较 max(s) 返回序列s的最大元素，s中元素需要可比较 s.index(x)或s.index(x,i,j) 返回序列s从i开始到j位置中第一次出现x的位置 s.count(x) 返回序列s中出现x的总次数 元组类型：元组是序列类型的一种扩展。 1.元组是一种序列类型，一旦创建就不能修改2.使用小括号()或tuple()创建，元素间用逗号分隔3.可以使用或不适用小括号 列表类型：是序列类型的一种扩展，十分常用。 1.列表是一种序列类型，创建后可以随意被修改2.使用方括号[]或list()创建，元素间用逗号隔开3.列表中各元素类型可以不同，无长度限制 列表类型操作函数和方法 函数或方法 描述 ls[i]=x 替换列表ls第i元素为x ls[i:j:k]=lt 用列表lt替换ls切片后所对应元素子列表 del ls[i] 删除列表ls中第i元素 del ls[i:j:k] 删除列表ls中第i到第j以k为步长的元素 ls += lt 更新列表ls，将列表lt元素增加带列表ls中 ls *= n 更新列表ls，其元素重复n次 ls.append(x) 在列表ls最后增加一个元素x ls.clear() 删除列表ls中所有元素 ls.copy() 生成一个新列表，赋值ls中所有元素 ls.insert(i,x) 在列表ls的第i位置增加元素x ls.pop(i) 将列表ls中第i位置元素取出并删除该元素 ls.remove(x) 将列表ls中出现的第一个元素x删除 ls.reverse() 将列表ls中的元素反转 6.3 字典类型及操作 字典类型：是“映射”的体现。 1.映射是一种键（索引）和值（数据）的对应2.字典是键值对的集合，键值对之间无序3.采用大括号{}和dict()创建，键值对用冒号:表示 字典类型操作函数和方法 函数或方法 描述 del d[k] 删除字典d中键k对应的数据值 k in d 判断键k(索引)是否在字典d中，如果在返回True，否则返回False d.keys() 返回字典d中所有的键信息 d.values() 返回字典d中所有值信息 d.items() 返回字典d中所有键值对信息 d.get(k,’default’) 键k存在，则返回相应值，不存在则返回’default’值 d.pop(k,’default’) 键k存在，则取出相应值，不存在则返回’default’值 d.popitem() 随机从字典d中取出一个键值对，以元组形式返回 d.clear() 删除所有的键值对 len(d) 返回字典d中元素的个数 6.4 jieba库的使用jieba库：是优秀的中文分词第三方库1.中文文本需要通过分词获得单个的词语2.提供三种分词模式 安装jieba库：：Windows环境下打开cmd命令行，输入pip install jieba命令，安装之后会提示Successfully installed即安装完成。 jieba库的使用：三种模式：精确模式、全模式、搜索引擎模式 1.精确模式（最常用）：把文本精确的切分开，不存在冗余单词2.全模式：把文本中所有可能的词语都扫描出来，有冗余3.搜索引擎模式：在精确模式基础上，对长词再次切分 jieba库常用函数 函数 描述 jieba.lcut(s) 精确模式，返回一个列表类型的分词结果 jieba.lcut(s,cut_all=True) 全模式，返回一个列表类型的分词结果，有冗余 jieba.lcut_for_search(s) 搜索引擎模式，返回一个列表类型的分词结果，有冗余 jieba.add_word(w) 向分词词典增加新词w 6.5 实例：文本词频统计利用jieba库测试smartcity.txt文件的词频，代码如下 1234567891011121314151617181920212223242526import jiebatxt &#x3D; open(&quot;smartcity.txt&quot;, &quot;r&quot;, encoding&#x3D;&quot;utf-8&quot;).read()words &#x3D; jieba.lcut(txt)counts &#x3D; &#123;&#125;for word in words: if len(word) &#x3D;&#x3D; 1: continue else: counts[word] &#x3D; counts.get(word, 0) + 1items &#x3D; list(counts.items())items.sort(key&#x3D;lambda x:x[1], reverse&#x3D;True)for i in range(10): #输出前10 word, count &#x3D; items[i] print(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word, count)) 运行结果：城市 46创新 38智慧 30社会 16发展 14应用 12形态 11技术 10信息技术 92.0 9 程序运行过程中一直出现报错ModuleNotFoundError: No module named &#39;jieba&#39;.，重新安装jieba库也不行，最后解决方式：将Python安装路径下D:\\Program Files (x86)\\Python\\Python37\\Lib\\site-packages的jieba文件夹复制到工程目录下，程序运行成功。 7. 文件和数据格式化7.1 文件的使用 文件：是数据的抽象和集合 1.文件是存储在辅助存储器上的数据序列2.文件是数据存储的一种形式3.文件展现形式：文本文件和二进制文件 文件的打开和关闭 1.打开文件：&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)文件名包括文件路径和名称，与程序文件同目录可省略路径，例&quot;D:/Python/f.txt&quot;、&quot;./Python/f.txt&quot;、&quot;D:\\\\Python\\\\f.txt&quot;、&quot;f.txt&quot;2.打开模式 文件的打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 ‘+’ 与r/w/x/a异同使用，在原功能基础上增加同时读写功能 3.关闭文件：&lt;变量名&gt;.close() 文件内容的读取 操作方法 描述 &lt;变量名&gt;.read(size=-1) 读入全部内容，如果给出参数，读入前size长度 &lt;变量名&gt;.readline(size=-1) 读入一行内容，如果给出参数，读入该行前size长度 &lt;变量名&gt;.readlines(hint=-1) 读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行 数据的文件写入 操作方法 描述 &lt;变量名&gt;.write(s) 向文件写入一个字符串或字节流，&gt;&gt;&gt;f.write(“中国是一个伟大的国家！”) &lt;变量名&gt;.writelines(lines) 将一个元素全为字符串的列表写入文件，&gt;&gt;&gt;ls=[“中国”, “法国”, “美国”]&gt;&gt;&gt;f.writelines(ls)&gt;&gt;&gt;中国法国美国 &lt;变量名&gt;.seek(offset) 改变当前文件操作指针的位置，offset含义如下：0-文件开头，1-当前位置，2-文件结尾 代码示例： 12345678910fo &#x3D; open(&quot;output.txt&quot;, &quot;w+&quot;)sl &#x3D; [&quot;中国&quot;, &quot;法国&quot;, &quot;美国&quot;]fo.writelines(ls)fo.seek(0) #写完之后将文件指针移到文件开头，再进行遍历输出for line in fo: print(line)fo.close()运行效果：中国法国美国 7.2 实例：自动轨迹绘制代码如下： 12345678910111213141516171819202122#AutoTraceDraw.pyimport turtle as tt.title(&#39;自动轨迹绘制&#39;)t.setup(800, 600, 0, 0)t.pencolor(&quot;red&quot;)t.pensize(5)#数据读取datals &#x3D; []f &#x3D; open(&quot;data.txt&quot;)for line in f: line &#x3D; line.replace(&quot;\\n&quot;, &quot; &quot;) if line !&#x3D; &quot; &quot;: #eval内参数为空时报错EOF，需加if判断 datals.append(list(map(eval, line.split(&quot;,&quot;))))f.close()#自动绘制for i in range(len(datals)): t.pencolor(datals[i][3], datals[i][4], datals[i][5]) t.fd(datals[i][0]) if datals[i][1]: t.right(datals[i][2]) else: t.left(datals[i][2]) 程序line13datals.append(list(map(eval, line.split(&quot;,&quot;))))中的eval函数内参数为空时报错，需要加入if判断，eval()语法为：eval(expression[, globals[, locals]])。expression参数不为空。 7.3 一维数据的格式化处理 数据组织的维度 一维数据：由对等关系的有序或无序数据构成，采用线性方式组织，对应列表、数组和集合等概念。二维数据：由多个一维数据构成，是一维数据的组合形式，表格是典型的二维数据。多维数据：由一维或二维数据在新维度上扩展形成。 一维数据的表示：列表（有序）或集合（无序）。 一维数据的存储:空格分隔、逗号分隔、特殊符号分隔。 一维数据的处理：字符串方法.split()和.join()。 7.4 二维数据的格式化处理 二维数据的表示：二维列表，每个列表元素又是一个列表。 CSV数据存储格式：由逗号分隔值的一种存储方式，每行一个一维数据，采用逗号分隔，无空行。 二维数据的处理：for循环+.split()和.join()。 7.5 wordcloud库的使用 wordcloud库是优秀的词云展示第三方库,词云是以词语为基本单位，更加直观和艺术的展示文本。 安装wordcloud库：：Windows环境下打开cmd命令行，输入pip install wordcloud命令，安装之后会提示Successfully installed即安装完成。安装过程中出现问题，在这个网站https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted下载库文件`wordcloud-1.7.0-cp37-cp37m-win_amd64.whl`，存放在库文件夹中，在该文件夹中执行命令`pip install wordcloud-1.7.0-cp37-cp37m-win_amd64.whl`即可。 wordcloud库的使用： 1.wordcloud.WordCloud()代表一个文本对应的词云2.可以根据文本中词语出现的频率等绘制词云3.绘制词云的形状、尺寸和颜色都可以设定 wordcloud库常规方法 方法 描述 w.generate(txt) 向WordCloud对象w中加载文本txt，&gt;&gt;&gt;w.generate(“Python and WordCloud”) w.to_file(filename) 将词云输出为图像文件，.png或.jpg格式，&gt;&gt;&gt;w.to_file(“outfile.png”) 配置对象参数w = wordcloud.WordCloud(&lt;参数&gt;) 参数 描述 width 指定词云对象生成图片的宽度，默认400像素，&gt;&gt;&gt;w=wordcloud.WordCloud(width=600) height 指定词云对象生成图片的高度，默认200像素，&gt;&gt;&gt;w=wordcloud.WordCloud(height=400) min_font_size 指定词云中字体的最小字号，默认4号，&gt;&gt;&gt;w=wordcloud.WordCloud(min_font_size=10) max_font_size 指定词云中字体的最大字号，根据高度自动调节，&gt;&gt;&gt;w=wordcloud.WordCloud(min_font_size=20) font_step 指定词云中字体字号的步进间隔，默认为1，&gt;&gt;&gt;w=wordcloud.WordCloud(font_step=2) font_path 指定字体文件的路径，默认None，&gt;&gt;&gt;w=wordcloud.WordCloud(font_path=”msyh.ttc”) max_words 指定词云显示的最大单词数量，默认200，&gt;&gt;&gt;w=wordcloud.WordCloud(max_words=20) stop_words 指定词云的排除词列表，即不显示的单词列表，&gt;&gt;&gt;w=wordcloud.WordCloud(stop_words=”Python”) mask 指定词云形状，默认为长方形，需要引用imread()函数，&gt;&gt;&gt;from scipy.misc import imread&gt;&gt;&gt;mk=imread(“pic.png”)&gt;&gt;&gt;w=wordcloud.WordCloud(mask=mk) background_color 指定词云图片的背景颜色，默认为黑色，&gt;&gt;&gt;w=wordcloud.WordCloud(background_color=”White”) 示例如下： 123456789101112131415161.一段英文生成词云import wordcloudtxt &#x3D; &quot;life is short, you need python&quot;w &#x3D; wordcloud.WordCloud(background_color&#x3D;&quot;white&quot;)w.generate(txt)w.to_file(&quot;ciyun1.png&quot;)2.一段中文生成词云import wordcloudimport jiebatxt &#x3D; &quot;购买自住住房申请住房公积金贷款的，不受缴存时间限制，按缴纳基数计算可贷额度，贷款额度可放宽至最高额度的2倍。&quot;w &#x3D; wordcloud.WordCloud(width&#x3D;1000, font_path&#x3D;&quot;Alibaba-PuHuiTi-Medium.ttf&quot;, height&#x3D;700)w.generate(&quot; &quot;.join(jieba.lcut(txt)))w.to_file(&quot;ciyun2.png&quot;)显示中文的字体文件的路径需要 font_path&#x3D;&quot;xxx&quot; 表示出来，或者直接将字体文件放在程序工程文件夹下，最后生成的词云图才会显示汉字。 7.6 实例：读取文件生成词云123456789101112131415161718192021222324252627282930311.读取 suzhou.txt 文件生成词云import wordcloudimport jiebaf &#x3D; open(&quot;suzhou.txt&quot;, &quot;r&quot;, encoding&#x3D;&quot;utf-8&quot;)t &#x3D; f.read()f.close()ls &#x3D; jieba.lcut(t)txt &#x3D; &quot; &quot;.join(ls)w &#x3D; wordcloud.WordCloud(font_path&#x3D;&quot;Alibaba-PuHuiTi-Medium.ttf&quot;, width&#x3D;1000, height&#x3D;700, background_color&#x3D;&quot;white&quot;)#生成的词云图中最多显示15个词语，通过 max_words&#x3D;xx 设置#w &#x3D; wordcloud.WordCloud(font_path&#x3D;&quot;Alibaba-PuHuiTi-Medium.ttf&quot;, width&#x3D;1000, height&#x3D;700, background_color&#x3D;&quot;white&quot;, max_words&#x3D;15)w.generate(txt)w.to_file(&quot;suzhou_ciyun.png&quot;)2.1.读取 suzhou.txt 文件生成词云，并生成特定形状import wordcloudimport jiebafrom scipy.misc import imreadmask &#x3D; imread(&quot;star.png&quot;)f &#x3D; open(&quot;suzhou.txt&quot;, &quot;r&quot;, encoding&#x3D;&quot;utf-8&quot;)t &#x3D; f.read()f.close()ls &#x3D; jieba.lcut(t)txt &#x3D; &quot; &quot;.join(ls)w &#x3D; wordcloud.WordCloud(font_path&#x3D;&quot;Alibaba-PuHuiTi-Medium.ttf&quot;, mask&#x3D;mask, width&#x3D;1000, height&#x3D;700, background_color&#x3D;&quot;white&quot;)#生成的词云图中最多显示15个词语，通过 max_words&#x3D;xx 设置#w &#x3D; wordcloud.WordCloud(font_path&#x3D;&quot;Alibaba-PuHuiTi-Medium.ttf&quot;, width&#x3D;1000, height&#x3D;700, background_color&#x3D;&quot;white&quot;, max_words&#x3D;15)w.generate(txt)w.to_file(&quot;pic_ciyun.png&quot;)安装scipy库和imread库，直接执行命令 pip install xxx ,出问题就提前下好库文件在安装，安装好两个库仍然报错ImportError: cannot import name &#39;imread&#39; from &#39;scipy.misc&#39;，需要降低scipy库，执行命令 pip install scipy&#x3D;&#x3D;1.2.0 问题解决，然后程序中选好特定图像文件，即可生成特定图像的词云。","categories":[],"tags":[]}],"categories":[],"tags":[]}